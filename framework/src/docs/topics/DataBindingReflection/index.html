<template>
  <div>

    



    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Live, reflective Data Binding</h1>
        <p>
          Data Binding is one way to program a controller to watch and synchronize the view with its model. Data binding can go both directions. 1 way and 2-way (bi directional). Essentially:
          <ul>
              <li>model -> view</li>
              <li>model <- view</li>
              <li>model <-> view</li>
          </ul>
          Unlike "data binding" implemented in most modern frameworks, bindings in Oros excel because the implementation focuses on:
          <ul>
              <li><b>Transparency:</b> You see what you are wiring up.</li>
              <li><b>Control:</b> Grandular ability to bind, unbind and transform  in | output</li>
              <li><b>Logic:</b> Logic in Controller, *never* in the View</li>
              <li><b>Speed:</b> More direct, no hidden fuzzy logic mapping</li>
              <li><b>Affordance:</b> .watch() and .unwatch() anything in the View, Model or both</li>
              <li><b>Dynamics:</b> Bindings can be dynamically generated at runtime. No compilation or build process. </li>
          </ul>
        </p>
        <p>
          Let's look at a simple case of binding 2 input boxes on a view with each other, 1-way and bi-directional. We're not forced to bind to a model, in Oros, anything can be bound to each other for synchronization.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Data binding syntax</h1>
        <p>
            Data Binding is integrated into WebComponents via a <code>.watch()</code> method with the
            following syntax:
            <pre class="inline javascript lang"><code>
this.watch(some_object, 'a_property', e => a_handler);

//Example: Watch person.firstname for changes
this.watch(person, 'firstname', e => console.log(e.val));
        </code></pre>
        </p>
        <p>
            Where:
            <ul>
                <li><code>some_object</code> - any object, model, element/Node</li>
                <li><code>a_property</code> - self explanatory, but a property of that object</li>
                <li><code>a_handler</code> - a callback that has access to the binding event, <code>e</code></li>
                <li>
                    <code>e</code> - An event passed to callback with what has changed {prop, old, val}
                    <ul>
                        <li><code>prop</code> - the name of the property in this binding</li>
                        <li><code>old</code> - the propertys old value</li>
                        <li><code>val</code> - the propertys new value</li>
                    </ul>
                </li>
            </ul>
        </p>
        <p>
            The above snippet simply logs the new value of <code>person.firstname</code> whenever changes are detected at the member level. A slightly
            more realistic use-case would be to render the changes unto the View in a <code>div</code> tag or a text box:
            <pre class="inline javascript lang"><code>
this.watch(person, 'firstname', e => aDiv.innerHTML = e.val);
        </code></pre>

        <pre class="inline javascript lang"><code>
//old-school functions work too
this.watch(person, 'firstname', function(e) { aDiv.innerHTML = e.val});
        </code></pre>


        <pre class="inline javascript lang"><code>
//As well as Class methods for advanced handling / formatting
this.watch(person, 'firstname', e => this.onFirstNameChanged(e));
        </code></pre>
        </p>

        <p>
            Any object and property could be bound to any object and property, in one direction or both. It does not have to be any particular object. Objects can be elements in the View. Elements can be bound to other elements, or an element to a model. This 1:1 mapping is simple enough to combine in interesting ways.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">1-Way Binding</h1>
        <p>
            Our View has 2 input fields in this example. Since we are able to bind any 2 things together,
            let's bind these in 1-direction, so that when source changes in value, destination will reflect the source and stay synchronized with each other. Code example to the right.
            <view-view-binding bind-type="single">
                <template>
                    <div>
                        <h3>Example 1: View -> View (1-way)</h3>
                        <span style="width:130px;display: inline-block;">SOURCE:</span> <input id="input1"/>
                        <br/>
                        <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input2" disabled/>
                    </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 1: 1-way binding from source to destination elements.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var source = this.querySelector("#input1");
var dest = this.querySelector("#input2");
//bind it
this.watch(source, 'value', e => dest.value = e.val);
        </code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">2-Way Binding</h1>
        <p>
            Here are the same 2 input elements in the View. Let's bind them bi-directionaly so that either one will reflect its value in the other, synchronizing their values.
            <view-view-binding bind-type="both">
                <template>
                    <div>
                        <h3>Example 2: View -> View (2-way)</h3>
                        <span style="width:130px;display: inline-block;">SOURCE:</span> <input id="input1" value=""/>
                        <br/>
                        <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input2"/>
                    </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 2: 2-way binding from and to source and destination.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var source = this.querySelector("#input1");
var dest = this.querySelector("#input2");
//bind them to each other
this.watch(source,'value', e => dest.value   = e.val);
this.watch(dest,  'value', e => source.value = e.val);
        </code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">1-Way Binding to a Model</h1>
        <p>
            Let's say we have a simple object{} having a firstname property, it's in our Controller. We can bind from this model to the input box in the View the same way.
            <view-view-binding bind-type="both">
                <template>
                    <div>
                    <h3>Example 3: Model -> View (1-way)</h3>
                    <span style="width:130px;display: inline-block;">MODEL:</span> <code>var user = {firstname: "Bill"};</code>
                    <br/>
                    <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input1" disabled/>
                    <div><em>HINT:</em> try to change <code>user.firstname=</code> in dev console to see view update</div>
                </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 3: 1-way binding from data model to element(view).
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var user = {firstname:""};
var dest = this.querySelector("#input1");
//bind them
this.watch(user, 'firstname', e => dest.value = e.val);
</code></pre>

        <blockquote class="javascript" style="display:block;width: 100%;">
            At a later time, we update model (try it in console)
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>//in console
user.firstname = "Ted";</code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Data Binding is a convenience, but not in todays modern frameworks</h1>
        <p>
            Data Binding is just one strategy for a Controller to synchronize its state with its view. With just one line of code:
          <pre class="inline javascript lang"><code>
this.watch(source, 'value', e => dest.value = e.val);
        </code></pre>
        </p>
        <p>
            We are able to dynamically, and automatically synchronize in real-time, the state (values) of 2 things. Its merely a convenience that can easily be abused because of its simplicity. You don't have this option in most modern frameworks. The frameworks today make binding a fully integrated and central part of it's architecture. This leads to problems.
        </p>
        <p>
            <ul>
                <li><b>Separation of Concerns:</b> Violated. Frameworks today force bindings to be declared in HTML with faux JavaScript fragments littering the View</li>
                <li><b>Readability:</b> The HTML goes from supple and lean, to messy, complex multi-line wrap-arounds, hard to read, hard to understand.</li>
                <li><b>OCP Violation:</b> Most frameworks today lump html, javascript and css into one file or a "Higher Order Function". A small edit might span a few areas, or touching all areas at times.</li>
                <li><b>Performance:</b> Binding is magic. There is a good amount of listeners and polling running on the CPU to check "dirty flags" and keep things mirrored</li>
                <li><b>No Flexibility:</b> Because binding in most frameworks are based on having a model or "prop" types, DOM manipulation isn't easily possible unless you alter the models, a strict form of MVC.</li>
                <li><b>Performance:</b> Due to frameworks constantly monitoring state to render it's view, it leads one to believe that this kind of "loop" runs at some interval, thereby simulating a poor-mans game loop with non-deterministic behavior</li>
                <li><b>Compilation:</b> It's not live. These "faux" bindings in HTML are not native, or semantically meaningful to browsers and must be pre-compiled to generate parsable syntax for the browser.</li>
                <li><b>Debugging:</b> good luck!</li>
            </ul>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>
  </div>
</template>