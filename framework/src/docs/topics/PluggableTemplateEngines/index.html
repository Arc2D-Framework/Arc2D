<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Pluggable Template Engines</h1>
        <p>
          So you hate JSX, but love Mustache. You like Template Literals and can't stand Handlebars. Some prefer JSP-style &#x3C;%= %&#x3E; syntax. Maybe you rather roll your own parser from scratch. Oros allows custom template engines (drivers) to be "plugged" in. With this architecture, you are able to use any 3rd party engines at the grandular WebComponent level. Some of your components in the system could use Nunjucks, some components, Handlebars, others, Dot.

          <p>WebComponents rely only on an adapted interface, the dependency to a concerete template engine or driver is inverted. This makes it possible for the framework itself to dynamically determine and dispatch rendering to any parser.</p>
          <img src="src/docs/images/template_driver_interface.png"/>

          <p>Any of these template engines can be used by writing a custom driver for each</p>
          <ul>
              <li><a href="https://developers.google.com/web/updates/2015/01/ES6-Template-Strings" target="new">ES6/7 Template Literals <i style="color:#a18dcc;">(Default)</i></a></li>
              <li><a href="https://mustache.github.io/" target="new">Mustache</a></li>
              <li><a href="http://handlebarsjs.com/" target="new">Handlebars</a></li>
              <li><a href="https://mozilla.github.io/nunjucks/" target="new">Nunjucks (by Mozilla)</a></li>
              <li><a href="http://underscorejs.org/" target="new">Underscore</a></li>
              <li><a href="https://ejs.co/" target="new">EJS</a></li>
              <li><a href="https://pugjs.org/" target="new">Jade/Pug</a></li>
              <li><a href="https://squirrelly.js.org/" target="new">Squirrelly</a></li>
              <li><a href="https://www.jsviews.com/#jsrender" target="new">JsRender</a></li>
              <li><a href="http://ectjs.com/" target="new">ECT (Coffee Templates)</a></li>
              <li><a href="http://www.idangero.us/template7/" target="new">Template7</a></li>
              <li><a href="https://olado.github.io/doT/" target="new">DoT</a></li>
              <li><em>Your own custom parser</em></li>
          </ul>
        </p>
        <p>
            Oros ships with a native ES6/7 template literals parser which is 
            fast, uses javascript-syntax, supple and powerful. But if you would like to use Mustache for example, a driver should be created, which delegates to Mustache for parsing. At minimum, a driver must implement:
        </p>
        <p>
            <table>
                <thead>
                <tr>
                  <th>Method/Attribute</th>
                  <th>Arguments</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>parse(tempStr, data, self)</code></td>
                  <td>
                      <ul style="margin: 0;padding: 0;">
                          <li><code>tempStr</code> - template input src</li>
                          <li><code>data</code> - JSON data</li>
                          <li><code>self</code> - ref to the component</li>
                      </ul>
                  </td>
                  <td>parse() is called with 3 args, should return valid HTML</td>
                </tr>
                <tr>
                    <td><code>install()</code></td>
                    <td></td>
                    <td>Any configurations/settings that should be applied</td>
                </tr>
                <tr>
                    <td><code>name</code></td>
                    <td></td>
                    <td>A friendly name for the engine. Ex: "MustacheDriver"</td>
                </tr>
                <tr>
                    <td><code>ext</code></td>
                    <td></td>
                    <td>A custom file extension if applicable. Ex: ".mus"</td>
                </tr>
              </tbody>
            </table>
        </p>
      </div>
    </div>
      



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Exmple TemplateLiterals Driver (built-in)</h1>
        <p>
          As an example, here is the real source for the built-in TemplateLiterals driver.
        </p>
        <pre class="inline javascript lang"><code>
var TemplateLiterals = {
    name : "TemplateLiterals",
    ext : "",//defaults to .html
    parse : function(tempStr, data, self){
        var parse = (tempStr, templateVars) => {
            return new Function("return \`"+tempStr +"\`;").call(templateVars);
        }
        return parse(tempStr, data)
    }
};



//register with a custom mime-type
window.customTemplateEngines.define("template/literals", TemplateLiterals);
            </code></pre>
        <p> 
            This is what a driver for a template engine could look like. <em>A simple interface-adapter in most cases</em>. Define a <code>parse()</code>, it takes in a template string and data, evaluates it and returns HTML-syntax. <code>name</code> is for friendly identification and <code>ext</code> is an invented file extension (ex: .es6) in case you want multiple templates to be stored in the component-package by the templates mime-type extension.
        </p>
        <p>
            Note, <code>window.customTemplateEngines.define()</code>, is how a driver is registered with the framework. 2 args for <code>define(mime, driver_obj)</code>:
                <ul>
                    <li>mime-type - be creative, make one up, it's a unique 'key'</li>
                    <li>driver_obj - the driver</li>
                </ul>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Let's create a Nunjucks Driver</h1>
        <p>
          Download <a href="https://mozilla.github.io/nunjucks/getting-started.html" target="new">nunjucks.js api</a> file, save it into the projects "src/libs/" directory. Create a
          NunjucksDriver.js, save it into "src/libs/" as well. 
        </p>
        <p>
          Template Drivers are simple Objects. Enter the following in NunjucksDriver.js:
        </p>
        <pre class="inline javascript lang"><code>
import "/framework/src/core/drivers/templating/Nunjucks/nunjucks.js";

var NunjucksDriver = {
        name : "Nunjucks",

        ext : ".nunj",

        parse : function(tempStr, data, self){
            return nunjucks.renderString(tempStr, data);
        },

        install : function(){
            nunjucks.configure({ autoescape: true });
        }
    };

window.customTemplateEngines.define("template/nunjucks", NunjucksDriver);
            </code></pre>
        <p> 
            Nunjucks is a project by Mozilla. Template parsing is available via its <code>nunjucks.renderString(src, data)</code> api. We've configured autoscaping during <code>install()</code> and delegated parsing to the api. Next, it is registered under a unique mime-type, "template/nunjucks".
            That's it.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Using the Nunjucks Driver</h1>
        <p>
          Let's build a component to use this template engine. See: <a href="#docs.topics.UsingCustomDriver">Using custom template drivers</a>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

  </div>
</template>