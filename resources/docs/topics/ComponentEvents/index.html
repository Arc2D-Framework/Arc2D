<template>
    <div>




        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="intro">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Events</h1>
            <p>
              Arc uses an event-driven programming model for allowing components to communicate
              with each other without components having to know about the other. Arc relies on
              the event architecture proposed by W3C which every browser today supports,
              <a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_new">W3C DOM Event Architecture</a>
            </p>
            <p>
              Arc adheres closely to specs. So, a good understanding of the topic is necessary
              when building decoupled, modular graphical-interfaces.
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>









        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="propagation">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Event Propagation</h1>
            <p>
              <b>Propagate:</b><br/>
              "...transmit or be transmitted in a particular direction or through a medium."
            </p>
            <p>
              There is an ordered path of "Phases" whereby events travel (propagate) in a user interface:
              <ul>
                <li>Capture Phase</li>
                <li>Target Phase</li>
                <li>Bubble Phase</li>
              </ul>
            </p>
            <p>
              The 3 phases of the event move along the <code>child <-> parent(s)</code> path in the
              DOM tree. Each Phase is a starting point in its direction. Let's first visualize a DOM tree of an
              HTML <code>Table</code>. Tap-n-hold a child node to see the path that the event travels:
            </p>

            <dom-tree-view style="margin-top: 20px;margin-bottom: 25px;">
              <div slot="component" tag="table">
                <div tag="thead"></div>
                <div tag="tbody">
                  <div tag="tr">
                    <div tag="td"></div>
                    <div tag="td"></div>
                    <div tag="td"></div>
                  </div>
                </div>
              </div>
            </dom-tree-view>
            <p>
              As you can see, clicking on a <code>TD</code>, generates a <code>"click"</code> event-signal that propagates from child to parents when the event bubbles up:
              <br/>
              <code>TD -> TR -> TBODY -> TABLE</code>
            </p>
            <p>
              But also travels from parent back to child during the Capture phase:
              <br/>
              <code>TABLE -> TBODY -> TR -> TD</code>
            </p>
            <p>
              The diagram simulates the path the event will travel for all 3 phases: capturing, targeting and bubbling. It does not show the order in which the phases occur over time. For that, we should now look at the life-cycle of the event along the travel path to understand the sequence of directional movements, or propagation of the signal.
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>






        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="capture">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Event Propagation: Capture Phase</h1>
            <p>
              The Capture phase occurs 1st along the travel path. This static diagram from W3C, shows a
              more complete DOM tree where the window (the ultimate parent) is notified first. And then, the signal travels down
              to each child in the pathway, making a quick stop at the child (the Event Target) that spawned the event.
            </p>
            <event-phase-diagram phase="capture_phase"></event-phase-diagram>
            <p>
              The capture phase allows a parent to intercept and, process or stop the event before any other child is allowed to handle it. The next phase of the event is the Target Phase.
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>





        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="target">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Event Propagation: Target Phase</h1>
            <p>
              When the event travels down, and makes a quick stop at the child that generated the event, it is called
              the Target Phase (the 2nd step of the event propagation life-cycle). At this point, the child itself is able
              to listen for, and handle, the event before it begins the next phase of travel, the Bubbling Phase.
            </p>
            <event-phase-diagram phase="target_phase"></event-phase-diagram>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>




        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="bubble">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Event Propagation: Bubble Phase</h1>
            <p>
              After the event is processed by the child that spawned it's own event at the Target Phase, the event
              makes its way back up the DOM tree to the ultimate parent (window). This is known as the Bubbling Phase.
            </p>
            <event-phase-diagram phase="bubble_phase"></event-phase-diagram>
            <p>
              We've covered all 3 phases of the event life-cycle.
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>



        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="target_phase_registration">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Real World Usage: Target Phase Registration</h1>
            <p>
              Imagine we had a Product component with an "Add to Cart" button. The
              html for our component is defined in the Products html <code>template</code>:
              <pre class="inline html lang">
                <code>
&#x3C;template&#x3E;
    &#x3C;div&#x3E;Egyptian Wool Blanket&#x3C;/div&#x3E;
    &#x3C;div&#x3E;..desc here&#x3C;/div&#x3E;
    &#x3C;button id=&#x22;add-to-cart&#x22;&#x3E;&#x3C;/button&#x3E;
&#x3C;/template&#x3E;
                </code>
              </pre>
            </p>
            <p>
              Since the button is clicked, and dispatches the event right at the source (the Event Target),
              we are able to register a listener on the event target phase explicitly:
              <pre class="inline javascript lang">
                <code>
namespace \`core.ui\` (
  class Product extends core.ui.StoreItem {
    onConnected(){
      var addBtn = this.querySelector("#add-to-cart");
      addBtn.addEventListener("click", e => this.onSendToCart(e));
    }

    onSendToCart(e){
      //Add item to cart
    }
  }
)
                </code>
              </pre>
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>







        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="bubble_phase_registration">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Real World Usage: Bubble Phase Registration</h1>
            <p>
              Alternatively, since the button is a child inside the Product component,
              and Product is one of the parents that own the button, we could register a listener on the Product itself since the event will eventually bubble up from the button (child).
              <pre class="inline javascript lang">
                <code>
namespace \`core.ui\` (
  class Product extends core.ui.StoreItem {
    onConnected(){
      this.addEventListener("click", e => this.onSendToCart(e));
    }

    onSendToCart(e){
      //Add item to cart
    }
  }
)
                </code>
              </pre>
            </p>
            <h3>Event Filtering</h3>
            <p>
              The only concern with the bubbling of events is that the parent will have to know what Event Target
              actually triggered the "click". The click signal could have originated from the button, or from click/tapping on the description text or even the price label.
            </p>
            <p>
              So how do we determine where the event bubbled up from at the parent level? Arc allows the parent to
              filter out events based on a css selector as a 4th argument to <code>addEventListener()</code>. This
              means you'll have to pass the full method-signature if using the 4th argument:
              <pre class="inline javascript lang">
                <code>
addEventListener(eventname, callback, capture, css);
                </code>
              </pre>

              <p>For Example:</p>
              <pre class="inline javascript lang">
                <code>
namespace \`core.ui\` (
  class Product extends core.ui.StoreItem {
    onConnected(){
      this.addEventListener("click", e => this.onSendToCart(e), false, "#add-to-cart");
    }

    onSendToCart(e){
      //Add item to cart
    }
  }
)
                </code>
              </pre>
              That filters clicks on the <code>#add-to-cart</code> button, which runs our handler, <code>onSendToCart()</code>, only for clicks on that particular node.
            </p>
            <p>
              Alternatively, you may use the alias, <code>on()</code>
              <pre class="inline javascript lang">
                <code>
on(eventname, callback, capture, css);
                </code>
              </pre>
            </p>
            <p>
              The same idea can be used to intelligently wire-up events that are bubbling from multiple child nodes for event filtering using the alias <code>on()</code>
              <pre class="inline javascript lang">
                <code>
namespace \`core.ui\` (
  class Product extends core.ui.StoreItem {
    onConnected(){
      this.on("click", e => this.onSendToCart(e), false, "#add-to-cart");
      this.on("click", e => this.onDescriptionClicked(e), false, "#desc");
      this.on("click", e => this.onPriceClicked(e), false, "#price");
    }

    //... handlers here
  }
)
                </code>
              </pre>
            </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>









        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="capture_phase_registration">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Real World Usage: Capture Phase Registration</h1>

            <p>
              In an Arc application, there is an actual <code>Application</code> that
              represents the screen being seen. It roughly acts as the body of the application,
              and being the ultimate managed parent of everything assembled on screen, it
              may participate in the Capture and Bubble Phase of the event life cycle.
            </p>

            <p>
              So, given we have a <code>Catalog</code> application that has a list of Products assembled
              on screen:
              <pre class="inline javascript lang">
                <code>
namespace \`core.applications\` (
  class Catalog extends Application {

  }
)
                </code>
              </pre>
            </p>
            <p>
              We could let the Catalog, being the parent of the screen, capture clicks from any add-to-cart button during the 1st phase of the event life-cycle by passing <code>true</code> as the 3rd argument to <code>addEventListener()</code>:
              <pre class="inline javascript lang">
                <code>
namespace \`core.applications\` (
  class Catalog extends Application {
    async onConnected(){
      await super.onConnected();
      this.addEventListener("click", e => this.onAddToCartRequested(e), true, "#add-to-cart");
    }

    onAddToCartRequested(e){
      //captured user trying to add a product to cart
    }
  }
)
                </code>
              </pre>
            </p>
            <p>
              If we were to conceptually represent this hierarchy, you'd see a Catalog app having many Products, each having its own button for adding to cart. Tap-n-hold the add to cart <code>button</code> in any Product.
              The event propagation path lights up, and we are able to intercept and capture the event as priority from the Catalog level.
            </p>
            <dom-tree-view style="margin-top: 20px;margin-bottom: 25px;">
              <div slot="component" tag="catalog">
                <div tag="product">
                  <div tag="name"></div>
                  <div tag="desc"></div>
                  <div tag="price"></div>
                  <div tag="button"></div>
                </div>
                <div tag="product">
                  <div tag="name"></div>
                  <div tag="desc"></div>
                  <div tag="price"></div>
                  <div tag="button"></div>
                </div>
                <div tag="product">
                  <div tag="name"></div>
                  <div tag="desc"></div>
                  <div tag="price"></div>
                  <div tag="button"></div>
                </div>
              </div>
            </dom-tree-view>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang"></div>
            <div class="html lang"></div>
            <div class="css lang"></div>
          </div>
        </div>








        <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="example">
          <div style="width: 50%;padding: 22px;">
            <h1 id="api-reference">Example: Toggle Button</h1>
            <p>Let's build a toggle button. The HTML for this component will be simple. The JavaScript
              involves a 2D Vector/Matrix transformation that can be ignored. What we're interested
              in here is how components can rely on events bubbling up from their child nodes as well
              as being able to filter events emitted from certain child nodes.
              <pre class="inline html lang">
                <code>
&#x3C;template&#x3E;
    &#x3C;div class="knob"&#x3E;&#x3C;/div&#x3E;
&#x3C;/template&#x3E;
                </code>
              </pre>
              The custom tag will be used declaratively this way in markup:
              <pre class="inline html lang">
                <code>
&#x3C;toggle-button&#x3E;&#x3C;/toggle-button&#x3E;
                </code>
              </pre>
            </p>
            <p>The DOM tree that is generated resembles:</p>

            <dom-tree-view style="margin-top: 20px;margin-bottom: 25px;height: 160px;">
                <toggle-button slot="component"></toggle-button>
            </dom-tree-view>

            <p>
              Here's what our button will look like:
            </p>
            <toggle-button></toggle-button>
            <p>
              And here's a 3D view of the DOM tree, click-n-drag to see the parts that make-up the toggle button
              from different angles:
            </p>
            <dom-view style="margin-bottom: 30px;">
                <toggle-button slot="component" class="transformed screen"></toggle-button>
            </dom-view>
            <p>
              The code snippets on the right show the full source. Related to this chapter is
              the <code>addEventListener()</code> registration. Notice that we are using a filtered
              listener for clicks only emitted from the knob.
            </p>
            <pre class="inline javascript lang">
                <code>
this.addEventListener("click", e => this.onClick(e), false, ".knob");
                </code>
              </pre>
              <p>
                Of course, the alias <code>on()</code> could very well be used for
                more compact code:
              </p>
              <pre class="inline javascript lang">
                <code>
this.on("click", e => this.onClick(e), false, ".knob");
                </code>
              </pre>
              <p>
                Try removing the 4th argument in the event registration. This removes the filter for knob, meaning
                a click on the toggle-button within any of its child parts will still work because the logic has no interest
                in any particular childNode to drive the functionality.
              </p>
              <p>
                It gives the effect of a wider finger hot-spot; touching anywhere on the button triggers a directional toggle. This is a demonstration of how events can be wired and filtered to narrow down the target that is emitting the event. With the filter removed, the event simply bubbles up from the knob to the toggle-button element (parent).
              </p>
          </div>
          <div style="width: 50%;display: block;">
            <div class="shell lang"></div>
            <div class="javascript lang">
              <blockquote class="javascript" style="display:block;width: 100%;">
            See: docs/demos/ui/ToggleButton/index.js
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`docs.demos.ui\` (
  class ToggleButton  extends WebComponent  {
    async onConnected(){
            await super.onConnected();
            this.addEventListener("click", e => this.onClick(e), false, ".knob");
            this.addEventListener("transitionend", e => this.onStyleComputed(e));
            this.knob = this.querySelector("div");
            this.direction = -1;
        }

        onStyleComputed(style){
            this.bounds = this.getBoundingClientRect();
            this.knob_bounds = this.knob.getBoundingClientRect();

            var style = window.getComputedStyle(this.knob);
            var matrix = new DOMMatrix(style.transform);
            this.matrix = matrix;
        }

        onClick(){
            this.direction *= -1;
            this.onRender();
        }

        get x() {
            return this.direction > 0 ?
                this.bounds.width-this.knob_bounds.width-6 : 0;
        }

        onRender(){
            var vector = {x: this.x, y:0, z:0 }
            this.knob.style.transform = \`
                translate3d(\${vector.x||0}px,\${vector.y||0}px,\${vector.z||this.matrix.m43}px)
            \`;
        }
  }
)
        </code></pre>
            </div>
            <div class="html lang">
              <blockquote class="html" style="display:block;width: 100%;">
            See: docs/demos/ui/ToggleButton/index.html
          </blockquote>
          <pre class="highlight html" style="display:block;width: 100%;"><code>
&#x3C;template&#x3E;
    &#x3C;div class=&#x22;knob&#x22;&#x3E;&#x3C;/div&#x3E;
&#x3C;/template&#x3E;
        </code></pre>
            </div>
            <div class="css lang">
              <blockquote class="css" style="display:block;width: 100%;">
            See: docs/demos/ui/ToggleButton/index.css
          </blockquote>
          <pre class="highlight css" style="display:block;width: 100%;"><code>

toggle-button {
    width: 70px;
    height: 30px;
    display: block;
    background: lightgray;
    border-radius: 30px;
    box-sizing: content-box;
    padding: 3px;
    perspective: 3000px;
}

toggle-button div {
    transition: all .2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 30px;
    background: white;
    box-sizing: border-box;
    height: 100%;
    border-radius: 50%;
}

toggle-button.on div {
    transform: translate3d(0px,0px,0px);
}

        </code></pre>
            </div>
          </div>
        </div>



    </div>
</template>
