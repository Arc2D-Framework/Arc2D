<template>
  <div>


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Rendering Template Data</h1>
        <p>
          A component will usually have state. Maybe it's a simple object. It could be an array of database results, or maybe it's a more complex process being Modeled (i.e: How a Clock works). You would like to render this state|model within its template. Simply call <code>await this.render(withData)</code> at anytime:
        </p>
        <p>
        	<pre class="inline javascript lang">
            <code>
var person = {name: "Joe"};
await this.render(person)
            </code>
          </pre>
        </p>
        <p>
        	The call to .render() will re-evaluate the component's template each time to update it's DOM view. Call it multiple times if there is a need to keep the view in sync when state changes.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">When to render?</h1>
        <p>
          During a component's <code>onConnected()</code> phase, the engine will handle an internal call to .render(), should you rely on it, using <code>super.onConected(withData)</code>. It invokes an immediate rendering during this phase so that a component is seen as soon as it becomes connected to the DOM.
          <pre class="inline javascript lang">
            <code>
onConnected() {
    var person = {name: "Joe"};
    await super.onConnected(person);//internal call to .render() immediately
}
            </code>
          </pre>
        </p>
        <p>
        	You don't have to rely on the default order and timing in this manner. You may choose to override onConnected() with custom logic, and, only later when state is ready or has changed/updated, you then invoke .render() manually at your timing.
        	<pre class="inline javascript lang">
            <code>
onConnected() {
    var person = {name: "Joe"};
    //still renders immediately, but better control, as you'll soon see
    await this.render(person);
}
            </code>
          </pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Await Rendering</h1>
        <p>
        	Here's an example of awaiting the response from a Collection which could be a local JSON asset or a remote database query.
        	<pre class="inline javascript lang">
            <code>
onConnected() {
  await this.render({items : await Movies.find()});
}
          </code>
          </pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Event-driven Rendering</h1>
        <p>
          Events can be registered to trigger rendering as well. Imagine a button
          that, when clicked, will filter genres and show the new update.
          <pre class="inline javascript lang">
            <code>
onConnected() {
    this.addEventListener("click", e => this.filter(e));
    this.render({items : await Movies.find()});//start by showing all
}

filter(e){
    var movies = await Movies.find({genre: "Action"});//just action movies
    this.render({items : movies});//redraw template
}
            </code>
          </pre>
        </p>
        <p>
          The central idea here is that a call to .render() can happen deterministically at your timing to re-evaluate and display updates. When a component renders during onConnected(), it happens immediately so that something is visible, but can be run again and as often as necessary to keep the view in sync with its state.
        </p>
        <p>
          Let's take a minute to look at rendering from the perspective of a &#x3C;template&#x3E;. It'll receive the data from render. It's job is to transform this raw data back into HTML.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>


  </div>
</template>
