APIs<template>
  <div>

    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="API-reference">Preface</h1>
        <h3>Brief History</h3>
        <p>
          The Arc Engine is a native, W3C compliant ES6/7 framework for
          building enterprise-class 2D/Applications. Over a decade
          old, Arc began as a personal R&D project to reduce and reuse
          repetetive UI patterns, cuttting time and costs as a consultant on
          projects dating back to 2007. It has since evolved slowly across
          many prestegious companies to present and has been used primilarily for
          in-house internal applications. Arc is now going public.
        </p>
        <p>
          Arc interprets itself while running, eliminating most of the tooling and toolchains you'd need (see: embedding below). For a comparison, the article <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f" target="_new">Learning JS in 2016</a> is not satire, but the actual state of complexity introduced into JavaScript, destroying the fun factor from programming today. The Arc Engine takes it back to W3C compliance with native JavaScript, pure HTML5 (no JSX) and standard CSS, the brewing ingredients for the W3C WebComponent Spec. It is live and direct, leveraging the dynamic nature of native ECMAScript/ES6 with standard HTML5 to accomplish sophisticated solutions with elegance, delegating most of the work to the browser. Powerful features were carefully, and diligently
          hand-crafted into a kernel size of just @27kB (non-gzip, 18kb gzipped). Built to run on NodeJS, Electron, Mobile (app store via Cordova or Capacitor) and the Web.
        </p>
        <h3>Framework vs. API</h3>
        <p>
          Arc is a framework. <em><strong>To put it in simple terms:</strong> A framework calls you. You do not call a framework—as you would with an API.</em>
          Arc is a meta-prototype of a running, fully functional application
          designed into the kernel from birth. Arc serves as an abstract application able to run on it's own, autonomously, without supplying any additional code or directions until you wish to override. If you're familar
          with C++ or Java, the analogy can be likened to an Abstract Class,
          a barebones template able to be used but does nothing much until you supply
          overridable implementation via inheritance.
        </p>
        <p>
          In similar fashion, your application will inherit the Arc engine when
          embedded. Then, you supply overridable implementations to achieve results, or supply
          nothing and nothing happens. The internal workings and intricate hand-crafted details of inter-component-communication, life-cycle, collision, timing, physics,
          state and work-flow in Arc are the processes that make up it's running "engine". Only
          certain aspects of the Arc engine (framework) can be swapped or supplied by you with overrides, allowing it to call your code—never you calling Arc's code as you would with APIs.
        </p>
        <p>
          The difference is clear. An API is a library of dedicated objects and methods around a finer domain, like APIs for grandular I/O Disk or Network operations. Multiple APIs can be orchastrated to communicate with each other in a process that eventually yields
          a framework.
        </p>

        <h3>Embedding</h3>
        <p>
          Embed Arc in any existing web page within the <code>&#x3C;head&#x3E;</code> tag:
          <pre class="inline html lang">
            <code>
&#x3C;head&#x3E;
    &#x3C;script src=&#x22;node_modules/od-cocoon/framework.src.js&#x22; charset=&#x22;utf-8&#x22;&#x3E;&#x3C;/script&#x3E;
&#x3C;/head&#x3E;
            </code>
          </pre>
        </p>
        <p>
          The webpage should still function as it did before embedding Arc with no visual differences or added behaviors. At this point, the page is still a page, not an Application or World until you supply one.
          Here are some important notes:
          <ul>
            <li>No TypeScript</li>
            <li>No WebPack</li>
            <li>No Builds:  No Grunt, Gulp, Broccoli, Mimosa</li>
            <li>No "Tree Shaking"</li>
            <li>No Babel</li>
            <li>No Pre/Post Compilation stages (live and dynamic)</li>
            <li>No Nodemon</li>
            <li>Zero Config</li>
          </ul>
        </p>

        <h3>Applications and Worlds</h3>
        <p>
          An Application in Arc represents a web/mobile or desktop user interface on top of a system (backend). This is the one we're most familar with. Components such as Dialogs, Popups, Windows, Buttons, Menus, Navigation and so on work in an event-driven style, where user events such as "clicks" trigger interactions and feedback.
        </p>
        <p>
          A World is an application still, but steps at 60FPS using a input-update-render game loop common in
          most games. Not only is it driven by user events, but it's updated every 1/60th of a second allowing Sprites such as NPC's to be animated on Canvas or by DOM transforms.
          <a href="../dom-physics.html" target="_new"><img style="border:1px solid #dfdfdf;margin: 25px 0px;" src="/resources/docs/images/dom-physics.png"/></a>
          The World environment will have
          physics and forces applied to bodies. In traditional 2D game engines, the Canvas is cleared and repainted every step, pixel by pixel, giving the illusion of motion. Arc Worlds may also leverage
          DOM Nodes on top of a canvas that are only painted once. Then, they animate by transforms on the GPU, allowing HUD displays to be hand-crafted in HTML and overlay
          canvases in an efficient manner. DOM bodies such as DIVs also have physical bodies and participate
          in physics. This allows games to be rendered, some portions by canvas and some with DOM bodies
          using layed canvases. <goblin-enemy style="float:left;"></goblin-enemy>Both DOM/SVG bodies and Canvas pixels will co-operate on a display seamlessly.
          Character sprite animations, once accomplished by Canvas drawImage(), can now also be achieved as
          DOM Sprites using CSS animations to step the sprite-sheet. This essentially means a DIV can represent a Warrior character in the the same way that pixels are painted to animate sprite sheets. Canvases are highly performant. You now have the flexibility to leverage HTML and SVG canvases layered on top of the native Canvas like 3 glass panes―3 separate rendering technologies combined, each having its own
          trade-offs.
        </p>
        <p>
          Have a look at the <a href="../dom-physics.html" target="_new">dom-physics</a> demo. 3 canvases lay on top of each other. Some
          physical bodies are actually HTML div tags. Some, like Circles, are SVG bodies, and some are Canvas pixels. Without a developer or user already knowing this, it would appear to be a typical canvas
          rendering.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



  </div>
</template>
