<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Node Adoption</h1>
        <p>
          Node adoption replaces an existing DOM node while adopting that node as it's child. This comes in handy when there is no easy way to declare custom tags in an existing DOM or when modifying the HTML on an existing page is not allowed.
        </p>
        <p>
            Some use-cases are static HTML hand-offs from a design agency or decorating an existing page without touching the HTML that you have acquired. It's an approach to embellishing a GUI programmatically with custom behavior.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            We have a Date Picker. It relies on binding events unto an input which
            probably exists in it's template, but we're not interested in using
            its own UI but an existing DOM node as it's UI:
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`core.ui\` (
    class DatePicker extends w3c.ui.WebComponent {
        onConnected(){
            this.bind("input", "click", e => this.onInputClicked(e))
        }

        onInputClicked(e){
            //open a calendar to choose a date
        }
    }
);
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            And maybe the html page already has an input field that should work
            like a date picker. We can adopt that input into DatePicker letting it
            serve as the DatePickers UI.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var dateInput = document.querySelector("#input.date");//no meaning
var datePicker = new core.ui.DatePicker;
    datePicker.adopts(dateInput)
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            After adoption, the DatePicker instance replaces and adopts the meaningless "input" tag in the DOM and
            DatePicker's onConnected() fires off for wire-up. This essentially enhances the input with DatePicker features.
          </blockquote>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Example Use Case</h1>
        <p>
          Take for example this fragment of HTML that was acquired via a capture/scraping process or was an HTML deliverable (prototyped design, maybe auto-generated) from a design team that should not be modified, because the next iterative hand-off will change in structure perhaps.


          <pre class="inline html lang">
            <code>
&#x3C;div id=&#x22;date-picker&#x22;&#x3E;
    &#x3C;div&#x3E;
        ... other elements for picking dates
    &#x3C;/div&#x3E;
&#x3C;/div&#x3E;
            </code>
          </pre>
        </p>
        <p>
            Modifying the snippet above to wire-up functionality for that date-picker &#x3C;div&#x3E; is not efficient in this scenario, the next hand-off from your design team might have the node in a different location or it's structure changed. Redoing your modifications each iteration becomes unmanageable.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            We have a Date Picker. It relies on binding events unto an input which
            probably exists in it's template, but we're not interested in using
            its own UI but an existing DOM node as it's UI:
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`core.ui\` (
    class DatePicker extends w3c.ui.WebComponent {
        onConnected(){
            this.bind("input", "click", e => this.onInputClicked(e))
        }

        onInputClicked(e){
            //open a calendar to choose a date
        }
    }
);
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            And maybe the html page already has an input field that should work
            like a date picker. We can adopt that input into DatePicker letting it
            serve as the DatePickers UI.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var dateInput = document.querySelector("#input.date");//no meaning
var datePicker = new core.ui.DatePicker;
    datePicker.adopts(dateInput)
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            After adoption, the DatePicker instance replaces and adopts the meaningless "input" tag in the DOM and
            DatePicker's onConnected() fires off for wire-up. This essentially enhances the input with DatePicker features.
          </blockquote>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Doing it programmatically</h1>
        <p>
          Your page will have an Arc application class that manages the UI (SPA). During the onConnected() state of your application, find the existing element, and adopt it into the custom DatePicker component you created:

          <pre class="inline javascript lang">
            <code>
//within application
onConnected(){
  var dateDiv = this.querySelector("div#date-picker");
  var datePicker = new core.ui.DatePicker;
      datePicker.adopts(dateDiv)
}
            </code>
          </pre>
        </p>
        <p>
          AFTER:
<pre class="inline html lang">
            <code>
&#x3C;date-picker namespace=&#x22;core.ui.DatePicker&#x22;&#x3E;
    &#x3C;div id=&#x22;date-picker&#x22;&#x3E;
        &#x3C;div&#x3E;
            ... other elements for picking dates
        &#x3C;/div&#x3E;
    &#x3C;/div&#x3E;
&#x3C;/date-picker&#x3E;
            </code>
          </pre>
        </p>
        <p>
          After adoption, the existing node becomes the new DOM/UI for DatePicker.
          <img src="docs/images/node_adoption.png"/>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            We have a Date Picker. It relies on binding events unto an input which
            probably exists in it's template, but we're not interested in using
            its own UI but an existing DOM node as it's UI:
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`core.ui\` (
    class DatePicker extends w3c.ui.WebComponent {
        onConnected(){
            this.bind("input", "click", e => this.onInputClicked(e))
        }

        onInputClicked(e){
            //open a calendar to choose a date
        }
    }
);
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            And maybe the html page already has an input field that should work
            like a date picker. We can adopt that input into DatePicker letting it
            serve as the DatePickers UI.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var dateInput = document.querySelector("#input.date");//no meaning
var datePicker = new core.ui.DatePicker;
    datePicker.adopts(dateInput)
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            After adoption, the DatePicker instance replaces and adopts the meaningless "input" tag in the DOM and
            DatePicker's onConnected() fires off for wire-up. This essentially enhances the input with DatePicker features.
          </blockquote>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

  </div>
</template>