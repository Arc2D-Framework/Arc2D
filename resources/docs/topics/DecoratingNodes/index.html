<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Decorating Nodes</h1>
        <p>
          Existing <b>DOM nodes</b> may be decorated by <b>custom components</b>. The use-cases for node decoration is narrow and special. You may never use it, but it warrants an explanation why it will
          remain a supported long-term feature. You generally decorate a node generated by CMS and eCommerce platforms or was handed off by design/prototyping teams, agencies or from purchased (pre-made) templates and UI kits.
        </p>
        <p>
            The use case goes like this, you have limited access to modifying HTML or might not want to modify the HTML in-line due to an evolving nature, but allowed to inject scripts into HEAD, meaning, Arc can run on your page. Here's how it works at runtime:
            <ul>
                <li>1. From your Application, find the Node to be decorated</li>
                <li>2. Initialize it as a Custom Component</li>
            </ul>

            So, imagine that the existing HTML page had a <code>&#x3C;div&#x3E;</code> tag that should be decorated by one of your custom components:
            <pre class="inline html lang"><code>
&#x3C;div id=&#x22;some-existing-module&#x22;&#x3E;
    &#x3C;div&#x3E;
        ... other elements here
    &#x3C;/div&#x3E;
&#x3C;/div&#x3E;
        </code></pre>
        </p>
        <p>
            From the main application that represents this screen, import your custom component (DatePicker example)
            <pre class="inline javascript lang"><code>
import 'core.ui.DatePicker';

namespace \`applications\` (
    class PaymentsScreen extends w3c.ui.Application {
        onConnected(){
            //Your setup code here
        }
    }
);
        </code></pre>
        </p>
        <p>
            During onConnected(), find the node on screen, initialize it as a DatePicker.
            <pre class="inline javascript lang"><code>
import 'core.ui.DatePicker';

namespace \`applications\` (
    class PaymentsScreen extends w3c.ui.Application {
        onConnected(){
            var dateEl = this.querySelector("#date-picker");
            var datepicker = new core.ui.DatePicker(dateEl);
        }
    }
);
        </code></pre>
        </p>
        <p>
            The <code>&#x3C;div id=&#x22;some-existing-module&#x22;&#x3E;</code> node, will now be decorated by the component, when inspected, observe the <code>namespace</code> attribute tacked on to the div, letting you know it is now a DatePicker:
            <pre class="inline html lang"><code>
&#x3C;div id=&#x22;some-module&#x22; namespace=&#x22;core.ui.DatePicker&#x22;&#x3E;
    &#x3C;div&#x3E;
        ... other elements here
    &#x3C;/div&#x3E;
&#x3C;/div&#x3E;
        </code></pre>
        </p>
        <p>
            Interesting possibilities emerge, the DatePicker now runs in the scope of this div tag. It has access only to the childNodes and to the root element itself via <code
            >this.element</code>
            <pre class="inline javascript lang"><code>
namespace \`core.ui\` (
    class DatePicker extends WebComponent {
        onConnected(){
            console.log(this.element);//&#x3C;div id=&#x22;some-existing-module&#x22;&#x3E;
            this.bind("input", "click", e => this.onInputClicked(e))
        }

        onInputClicked(e){
            //open a calendar to choose a date
        }
    }
);
        </code></pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Remarks</h1>
        <p>
          This is the 3rd strategy for running custom components on your screen when modifying existing HTML is not possible or desired. It is faster that replacing or adpoting nodes because the existing DOM tree is never altered, cloned or replaced (no re-paint).
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Try It!</h1>
        <p>
          Below is a simple div, with a text-based input, click "Run" to decorate
          the div to run as the demo DatePicker component we've been using in the examples:
        </p>
        <div id="some-existing-module">
            <input type="text"/>
        </div>
        <button id="decorate">Decorate as DatePicker</button>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

  </div>
</template>