<template>
  <div>

    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">JavaScript Imports</h1>
        <p>
          See the Getting Started topic, <a href="#docs.topics.ImportingNamespaces">Imports</a>
        </p>
        <p>
          In addition to class and component level imports, basic ES6 destructuring
          is also supported. See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="new">Destructured Imports</a>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

    


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Static Imports</h1>
        <p>
          In the Getting Started topic, <a href="#docs.topics.ImportingNamespaces">Imports</a>, we covered the
          basics of the <code>import</code> keyword, a static (hard-coded) mechanism for resolving dependencies, a core feature of ES6 and can be used in conjunction with destructuring. Have a read on the details here on Mozilla Docs: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="new">import and destructuring</a>.
        </p>
        <h3>HOW IT AFFECTS A PRODUCTION BUILD</h3>
        <p>
          The Arc SDK build tool (Seam) automatically links, joins and compresses all static imports into a single minified file for
          production deployment. Its considered static importing because no logic or conditional statements can wrap 
          these calls, it is merely a "hard-coded" declaration to a dependency when you know the dependency never changes. This is unlike a dynamic import().
        </p>
        <h3>Performance</h3>
        <p>
          A production ready build will load faster than the dev/debug equivalent since non of the static
          <code>import</code> calls are made over http, everything will be bundled and compressed into a single
          http request, decreasing your load time.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            Various ways to use a static import. During a production build, Arcs Seam tool will link and compress all <code>import</code> declarations into the final optimized app runtime.
          </blockquote>
          <pre class="inline javascript lang">
            <code>
import! 'core.utils.Math';
import  'core.ui.ToggleButton';
import  '/src/core/utils/mathlib.js';
import {SomeModule} from '/src/core/utils/mathlib.js';
            </code>
          </pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Dynamic Imports</h1>
        <p>
          Arc supports dynamic imports via the <code>import()</code> or <code>require()</code> function and works
          just like a static import but logic and conditional statements can be used when you do not know what dependency
          will be needed at runtime.
        </p>
        <h3>HOW IT AFFECTS A PRODUCTION BUILD</h3>
        <p>
          Dynamic imports are ignored by the SDK build tools and are never resolved or included in the final compressed build. The <code>import()</code> or <code>require()</code> statement is left as-is in the compressed build and work as you expected it, resolving the imported dependencies at runtime, just-in-time.
        </p>

        <h3>require and import syntax</h3>
        <p>
          Arc supports the commonjs/nodejs <code>require()</code> module method in the browser, but
          works exactly the same (a polyfill) for ES6 dynamic <code>import()</code>. The following
          2 statements are equivalent:
          <pre class="inline javascript lang">
              <code>
await require('/node_modules/od-mingo/dist/mingo.es6.js');
await import ('/node_modules/od-mingo/dist/mingo.es6.js');
              </code>
          </pre>
          Alternatively, without <code>await</code>, some elegance is lost as it now becomes
          a "thenable" promise:
          <pre class="inline javascript lang">
              <code>
require('/node_modules/od-mingo/dist/mingo.es6.js').then(module => {
  console.log("mingo is reaady", module)
})
              </code>
          </pre>
          <br/>
          <p>Which is a glimpse into interesting ways to use this dynamically within  logic, importing
          "on-demand" dependencies right when they are needed. Here's a ficticious import, wrapped in
          an <code>if</code> statement:</p>
          <pre class="inline javascript lang">
              <code>
if(!mingo && this.engine_enabled) {
  require('/node_modules/od-mingo/dist/mingo.es6.js').then(module => {
    console.log("mingo is reaady", module)
  })
}
              </code>
          </pre>
        </p>
        <h3>Managed Modules</h3>
        <p>
          Arcs Seam tools will ignore any dynamic imports during build. This yields an interesting side-effect,
          better npm module management. Since your npm (node_modules) are dynamically linked and external to your
          app, you could version your modules, upgrade and reinstall them without having to rebuild your Arc
          project. One could imagine a mobile app leveraging this design for a "hot-update" feature, instant app
          updates all remote.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            Use <code>await</code> before dynamic imports for better control flow and readibility.
          </blockquote>
          <pre class="inline javascript lang">
            <code>
await import('/node_modules/od-mingo/dist/mingo.es6.js');


namespace \`applications\` (
    class HelloWorld extends Application {
        constructor(element){
            super(element);
        }

        async onConnected() {
            await super.onConnected();
        }
    }
);
            </code>
          </pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Destructured Imports</h1>
        <p>
          ES6 Destructured imports are also possible
        </p>
        <pre class="inline javascript lang">
              <code>
mingo = (await require('/node_modules/od-mingo/dist/mingo.es6.js')).default;
              </code>
          </pre>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
<blockquote class="javascript" style="display:block;width: 100%;">
            Use <code>await</code> before dynamic imports for better control flow and readibility.
          </blockquote>
          <pre class="inline javascript lang">
            <code>
mingo = (await require('/node_modules/od-mingo/dist/mingo.es6.js')).default;

namespace \`applications\` (
    class HelloWorld extends Application {
        constructor(element){
            super(element);
        }

        async onConnected() {
            await super.onConnected();
            if(mingo) {
              alert("Mingo api is ready for use")
            }
        }
    }
);
            </code>
          </pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

  </div>
</template>