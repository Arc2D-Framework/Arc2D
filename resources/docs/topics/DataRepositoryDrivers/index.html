<template>
  <div>



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="intro">
      <div style="width: 50%;padding: 22px;">
        <h1 id="what">What is a Driver?</h1>
        <p>
            Surely you have had the experience of buying and installing a new printer. Do you recall having to install software on your computer so it knows how to communicate with the printer? That software is a driver. Each printer comes with it's own driver.
            <img src="docs/images/printer-drivers.png" style="width:100%;margin-top:30px;"/>
        </p>
        <p>
            Installing a printer driver allows the computer to communicate with different printers seamlessly. The Driver collects the data to be printed and encodes/decodes and/or formats it in a particular way that the printer can understand in order to run a print job.
        </p>
        <p>
            Computers ship with generic printer drivers that work at the bare minimum. A user is able to swap printer drivers for a richer print experience, easily, without having to change the way they would print from a computer and without changing the computer. The core principle being, "Dependency Inversion", a design feature in software
            that breaks away from hard, low-level dependencies by allowing the system to rely on interfaces. The dependencies, then, are inverted depending on the interface (a port) specified by the system instead of the system depending on every detail of every kind of driver or technology. The system remains
            open to change, but closed for modification. Think of this design as "Plug-n-Play". See Ports & Adapters or Hexagonal Architecture, the core and principal design of Arc.
        </p>
        <h3>Storage Drivers</h3>
        <p>
            Like the printer driver analogy, Arc's storage interface allows developers to write and plug-in new types of drivers to deal with storage and retrieval of data on disk, memory or database without
            having to change much of anything in the application itself. The Application becomes resilient to
            the underlying technology.
            <img src="docs/images/data_access_repositories.png" style="margin-top:60px;">
        </p>
        <p>
            The layered diagram above shows 3 distinct layers of Arc. For brevity, all other details except
            the storage facilities are shown. The display or UI layer communicates with Collections in the Domain, which rely on an inverted storage interface. Collections rarely have to change when technology-specific I/O storage drivers are swapped.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="switching">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Switching Drivers</h1>
        <p>
          Modify the <code>driver</code> attribute of the Collection to communicate with
          a different storage platform/protocol. Here, we are switching to the <code>Memory</code> driver
          which reads/writes data to memory, working just like a Mongo-style NoSQL database:
          <pre class="inline javascript lang">
                <code>
import! 'system.drivers.storage.Memory';

namespace \`domain.collections\` (
    class Movies extends Collection {
        @public device_driver = "system.drivers.storage.Memory";
    }
);
                </code>
            </pre>
        </p>
        <p>
          CouchDB could be configured instead; the Collection is still resilient to the change,
          and no application code higher up in the layered architecture (the UI) needs modification:
          <pre class="inline javascript lang">
                <code>
import! 'system.drivers.storage.CouchDB';

namespace \`domain.collections\` (
    class Movies extends Collection {
        @public device_driver = "system.drivers.storage.CouchDB";
    }
);
                </code>
            </pre>
        </p>
        <p>
            From the perspective of the UI layer, components are still able to query
            for a list of all Movies to render in the same manner, and remain further resilient
            to changes at the system level:
            <pre class="inline javascript lang">
                <code>
var movies = await domain.collections.Movies.find({ title : "Batman"})
                </code>
            </pre>
        </p>
        <p>
            <img src="docs/images/data_access_repositories2.png">
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    <!-- <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="intro">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Repository Drivers</h1>
        <p>
          By default implementation, repository classes you create inherit from <code>core.data.Repository</code> and are driven by a Memory driver, meaning all data is stored, temporarily, in browser memory. As soon as the application (browser tab) is closed, the data is lost.
          <img src="docs/images/data_access_repositories2.png">
        </p>
        <p>
            This base setup allows you to rapidly prototype and build out core functionality without worrying about creating or defining technical driver details at the early stages of development. The theory goes: You should be able to swap out the driver of your repository for something like a Mongo driver without having to alter code that was written for UI components, it should just work with a different storage device.
        </p>
        <p>In this chapter, we'll explore what the default <code>Memory</code> driver looks like, which is utterly simple. With that piece of knowledge, <em>we'll build a simple Driver for CouchDB</em>, an enterprise-class NoSQL database. We'll then configure our Movies Repository to use the CouchDB driver.</p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>
 -->










  <!--   <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="a-db-problem">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">A Database Problem</h1>
        <p>
            The biggest challenge when creating your first app, learning, or working in an enterprise team will be data connectivity, the database. Building anything worth-while requires storing data. Here, many starting developers especially, make their way down the rabbit hole.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>
 -->




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;" id="memory-driver">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Example: Implementing a Memory Driver</h1>
        <p>
            Arc comes with a Memory driver that is available for use during development and
            Unit Testing. It is not part of the runtime, but can be imported by Collections
            before declaring it as the device driver:
        </p>
        <p>
            <pre class="inline javascript lang">
                <code>
import! 'system.drivers.storage.Memory';

namespace \`domain.collections\` (
    class Movies extends Collection {
        @public device_driver = "system.drivers.storage.Memory";
    }
);
                </code>
            </pre>
        </p>
        <p>
            As shown in the implementation details to the right, the Memory driver simulates
            a NoSQL database by keeping objects in memory using a simple hash-table: <code>{}</code>.
            <pre class="inline javascript lang">
                <code>
//Session.State.db is just a namespace instead of storing it on the global window.
Session.State.db = Session.State.db||{};
                </code>
            </pre>
        </p>
        <p>
            <code>isSeedingEnabled()</code> is a driver-level method that determines if this particular
        storage medium supports the ability to be seeded at start-up with some test data. Handy for writing
        Unit tests. <code>setCollection()</code> simply allocates an entry into the hash for keeping particular
        kinds of collections grouped by their name. When, and if, seeding is enabled, the collection will be pre-filled with items specified by the Collection. Collections that are able to seed should define
        a few more options:
            <pre class="inline javascript lang">
                <code>
import! 'system.drivers.storage.LocalStorage';

namespace \`domain.collections\` (
    class Movies extends Collection {
        @public device_driver = "system.drivers.storage.LocalStorage";
        @public seeds = REPOSITORIES.MOVIES;   /*see: app/resources/repositories.js*/

        static isSeedable(){
            return this.IRequestStorage.isSeedingEnabled();
        }
    }
);
                </code>
            </pre>
        </p>
        <p>
            "app/resources/repositories.js" -- is a list of .json paths that hold static seed data. This file
            is imported by the driver, and is available for reference in Collections.
        </p>
        <p>
            The rest of the methods, <code>add, find, remove, sort</code> etc., are the CRUD methods for
            dealing with the data in storage, and you are free to simulate or emulate the details in whatever way
            makes the most sense.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            <b>Memory Driver</b>
            Implements the contractual methods/API defined by <code>IStorageInterface</code>
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
import '/src/system/drivers/storage/Cursor.js';
import '/resources/repositories.js';
window.Query = (await require('/framework/src/libs/query.js')).default;

namespace \`system.drivers.storage\` (
    class Memory extends system.drivers.storage.IStorageInterface {
        constructor (collection, storage_device){
            super(collection, storage_device);
            Session.State.db = Session.State.db||{};
            this.setCollection(collection.name);
        }

        isSeedingEnabled(){
            return true;
        }

        setCollection (name){
            if(typeof Session.State.db[name] != "object"){
                Session.State.db[name] = [];
            }
            this.collection = Session.State.db[name];
        }


        add(obj, cb){
            this.collection.push(obj);
            cb&&cb(obj,null);
            return obj;
        }

        find(cb, query){
            var res = Query.query( this.collection, query.query||{});
            var cursor = new core.drivers.storage.Cursor(res,query,this);
            cb&&cb(cursor, null)
            return cursor;
        }

        remove(cb,query){
            var res = Query.query( this.collection, query.query||{});
            var removed=[];
            res.forEach(o => {
                for(var i=0; i<=this.collection.length-1; i++){
                    if(this.collection[i]._id == o._id){
                        this.collection.splice(i,1);
                        removed.push(o);
                    }
                }
            });
            cb && cb(removed,null);
            return removed;
        }


        sort(cursor, attrb, order){
            order = order==1?true:false;
            cursor.items.sort(function(a, b) {

                var nameA = a[attrb].toUpperCase(); // ignore upper and lowercase
                var nameB = b[attrb].toUpperCase(); // ignore upper and lowercase
                if(order){
                    if (nameA < nameB) {
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }

                    // names must be equal
                    return 0;
                } else {
                    if (nameA < nameB) {
                        return 1;
                    }
                    if (nameA > nameB) {
                        return -1;
                    }

                    // names must be equal
                    return 0;
                }
            });
            cursor.paginator.resetindex();
            return cursor;
        }
    }
);
</code>
      </pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>







  </div>
</template>
