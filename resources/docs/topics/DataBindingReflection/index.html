<template>
  <div>

    


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Watchers</h1>
        <p>
          A Watcher will observe and notify you of property/value changes on a source object. This
          mechanism allows for manual control of "bindings". Data Binding is a design-pattern facilitating the synchronization
          of property values between a source and destination object, so as to mirror the values -- for practicality, to collect and store values from the UI. This pattern
          is most prevalent and a commonly recurring theme between the UI(HTML User Interface) and it's JavaScript class.
        </p>
        <img style="width:100%;" src="docs/images/Watchers.png"/>
        <h3 id="api-reference" style="margin-top: 1.7em;">Usage</h3>
        <p>
          The diagram shows 4 possible bindings, via watchers, between JavaScript and HTML using <code>this.watch()</code>:
<pre class="inline javascript lang"><code>
this.watch("#email", 'value', e => this.email = e.val)
        </code></pre>
        <img style="width:100%;" src="docs/images/Watchers_2.png"/>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            <b>Example:</b> Watch and bind values being entered in a components UI (the source). See HTML tab for
            what the components UI could look like.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`display.components.UserRegistration\` (
  constructor(){
    super();
    this.email  = null;
    this.gender = null;
    this.dob    = null;
    this.terms  = null;

  }

  async onConnected(){
    await super.onConnected();
    this.watch("#email",      'value',    e => this.email = e.val);
    this.watch("#gender",     'value',    e => this.gender= e.val);
    this.watch("#birthdate",  'value',    e => this.dob   = e.val);
    this.watch("#terms",      'checked',  e => this.terms = e.val);
  }
)
          </code></pre>
        </div>
        <div class="html lang">
          <blockquote class="html" style="display:block;width: 100%;">
            <b>Example:</b> A simple component template to collect user values. The <code>&#x3C;input/&#x3E;</code>
            elements will be watched by the components class. See JavaScript tab.
          </blockquote>
          <pre class="highlight html" style="display:block;width: 100%;"><code>
&#x3C;template&#x3E;
  &#x3C;div&#x3E;
    &#x3C;form&#x3E;
      &#x3C;input type=&#x22;text&#x22; id=&#x22;email&#x22;/&#x3E;
      &#x3C;select id=&#x22;gender&#x22;&#x3E;
        &#x3C;option&#x3E;Gender&#x3C;/option&#x3E;
        &#x3C;option value=&#x22;male&#x22;&#x3E;Male&#x3C;/option&#x3E;
        &#x3C;option value=&#x22;female&#x22;&#x3E;Female&#x3C;/option&#x3E;
      &#x3C;/select&#x3E;
      &#x3C;input type=&#x22;date&#x22; id=&#x22;birthdate&#x22;/&#x3E;
      &#x3C;input type=&#x22;checkbox&#x22; id=&#x22;terms&#x22;/&#x3E; Agree to Terms
    &#x3C;/form&#x3E;
  &#x3C;/div&#x3E;
&#x3C;/template&#x3E;
          </code></pre>
        </div>
        <div class="css lang"></div>
      </div>
    </div>



    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Agnostic Design</h1>
        <p>
          Watchers can be bound bi-directionally as well. Some 1 & 2-way (bi directional) example combinations:
          <ul>
              <li>model -> view</li>
              <li>model <- view</li>
              <li>model <-> view</li>
              <li>model <-> model</li>
              <li>view <-> view</li>
          </ul>
        </p>
        <p>
          <em>Where "model" is synonymous for a variable/object in JavaScript and "view" is anything in the DOM</em>. Unlike "data binding" implemented in most modern frameworks, bindings in Arc excel because the implementation focuses on:
        </p>
        <p>
          <ul>
              <li><b>Transparency:</b> See directly what is being watched</li>
              <li><b>Control:</b> Ability to watch, unwatch & transform values easily</li>
              <li><b>Logic:</b> Separate technologies. No JS in HTML or special HTML attributes to learn</li>
              <!-- <li><b>Speed:</b> Direct to-the-metal watcher; no black-box magic.</li> -->
              <li><b>Affordance:</b> Gives us a "binding" mechanism via watchers, bi-directionally between
              any kinds of objects in theory and the ability to swap Watcher Engines out.</li>
              <!-- <li><b>Dynamics:</b> Bindings can be dynamically generated at runtime. No compilation or build process. </li> -->
          </ul>
        </p>
        <p>
          Most important is the agnostic design of the Watcher mechanism in Arc. Developers are able to completely replace
          the default engine used internally for watching. The Watcher concept is not hard-coded into the Arc Engine, here's
          the design:
          <img style="width:100%;" src="docs/images/custom_watchers.png"/>
        </p>
        <p>
          The default watcher, <code>system.drivers.watchers.Watcher</code>, is a simple class that observes any object dispatching <code>"change"</code> events. While this
          is sufficient for watching native form elements which all fire change events, it will not appear to work when
          watching custom components or non-dom objects unless those objects explicity fire change events by participating as
          Observers or EventTargets.
        </p>
        <p>
          Here's the entirety of the code for the buit-in default watcher to understand how you would implement your own:
          <pre class="inline javascript lang"><code>
namespace \`system.drivers.watchers\` (
    class Watcher {
        static watch(object,prop,cb,force){
            var data = {object, prop, old:object[prop], val:""};
            var _cb = () => {
                data.val=object[prop];
                cb(data);
            }
            object.addEventListener("input", _cb,false);
            object.addEventListener("change",_cb,false);
            force?cb(data):null;
            return {
                unwatch : function(){
                    object.removeEventListener("input", _cb, false);
                    object.removeEventListener("change",_cb, false);
                }
            }
        }
    }
);
        </code></pre>
        </p>
        <p>
          The <code>system.drivers.watchers.Watcher</code> is a very simple Watcher implementation that is based
          on EventTargets publishing change/input events, dom or non-dom objects. If an object does not fire 'change' events, the watch 
          bindings never fire and may produce an error saying the source object does not support an 'addEventListener'
          function. This implementation forces objects to broadcast 'change' events if they want to be watched. Let's see
          how custom objects could fire these events.
        </p>
          <!-- <toggle-button></toggle-button> -->
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Watching Custom Components</h1>
        <p>
          The default built-in Watcher above relies on 'change' and 'input' events natively fired by form elements. But what
          if you wanted to watch a custom component or non-dom object? You'd have to make them participate in
          Observations and fire the relevant events, here is the custom toggle component firing a custom 'change' event:
             <pre class="inline javascript lang"><code>
namespace \`docs.demos.ui\` (
  class ToggleButton extends WebComponent  {
    async onConnected(){
            await super.onConnected();

            this.knob = this.querySelector(".knob");
            this.value = -1;
            this.addEventListener("click", e => this.onClick(e), false);
            this.addEventListener("transitionend", e => this.onStyleComputed(e));
        }

        onClick(){
            this.value *= -1;
            this.dispatchEvent("change");
            this.onRender();
        }
        //rest of code commented for brevity
  }
)
        </code></pre>      
        </p>
        <p>
          Usage would be no different. Use the toggle tag in HTML, then watch
          it from JavaScript:
          <pre class="inline html lang"><code>
&#x3C;toggle-button id=&#x22;my-toggle&#x22;&#x3E;&#x3C;/toggle-button&#x3E;
Toggle State: &#x3C;span id=&#x22;show_state&#x22;&#x3E;&#x3C;/span&#x3E;
          </code></pre>


          <pre class="inline javascript lang"><code>
namespace \`docs.topics\` (
  class DataBindingReflection  extends docs.topics.Topic  {
    async onConnected(){
            await super.onConnected();
            this.show_state = this.querySelector("#show_state");
            this.watch("#my-toggle", "value", e=> this.onShow(e), true)
        }

        onShow(e){
            this.show_state.innerHTML = e.val==1 ? "On" : "Off"
        }
  }
)
          </code></pre>
        </p> 
        <h3>My Toggle Example:</h3>
        <toggle-button id="my-toggle"></toggle-button>
        Toggle State: <span id="show_state"></span>
        <p>
          <br/>
          The keen eye would notice a 4th boolean argument, this specifices to the Watcher
          engine whether to force a binding immediately or not. If not specified, <code>flase</code>
          is default and the bindings won't be detected until a change occurs on the source
          object.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>








    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Watching Custom Objects</h1>
        <p>
          Non-DOM Classes may implement the <code>Observer</code> trait to participate in
          watcher observattions by firing custom 'change' eventss as well:
             <pre class="inline javascript lang"><code>
@trait(new Observer);
namespace \`domain.entities\` (
  class Catapilla  {
    constructor(){
        this.makeCocoon();
    }

    makeCocoon(){
      if(this.in_cocoon){
        this.dispatchEvent("change");
      }
    }
  }
)
        </code></pre>      
        </p>
        <p>
          Usage would be similar:
          <pre class="inline javascript lang"><code>
var hungry_catipillar = new domain.entities.Catapilla;
this.watch(hungry_catipillar, "in_cocoon", e=> alert('Changes'))
          </code></pre>
        </p> 
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>








    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Wrist Wattch: A Robust Watcher by Andrea Giammarchi</h1>
        <p>
          A custom watcher engine could be used in place of the default via
          a 5th argument:
             <pre class="inline javascript lang"><code>
this.watch(hungry_catipillar, "in_cocoon", e=> alert('Changes'), [true, [Custom Watcher]]);
        </code></pre>      
        </p>
        <p>
          Wrist Watch, is a watcher implementation by Andrea Giammarchi that is
          far superior to the built-in watcher. It is available for import from the /src/system/drivers/watchers/
          folder and works on any type of object, dom and non-dom based, without having to
          fire custom events all the time, or force objects to be observers. Here's how you'd use it:
        </p> 
        <p>
          <pre class="inline javascript lang"><code>
import {WristWatch} from '/src/system/drivers/watchers/wrist_watch.js';

namespace \`display.components.UserRegistration\` (
  constructor(){
    super();
    this.email  = null;
    this.gender = null;
    this.dob    = null;
    this.terms  = null;

  }

  async onConnected(){
    await super.onConnected();
    this.watch("#email",      'value',    e => this.email = e.val, true, WristWatch);
    this.watch("#gender",     'value',    e => this.gender= e.val, true, WristWatch);
    this.watch("#birthdate",  'value',    e => this.dob   = e.val, true, WristWatch);
    this.watch("#terms",      'checked',  e => this.terms = e.val, true, WristWatch);
  }
)
        </code></pre> 
        </p>
        <p>
          <a href="https://github.com/sindresorhus/on-change" target="_new">onChange</a> is another npm library that is a bit more heavy and based on Proxies,
          try experimenting or writing your own. The built-in solution is usually sufficient,
          offering more control and is optimized as a result of being lite-weight.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>











    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Writing a custom Watcher</h1>
        <p>
          A custom watcher should follow the implementation pattern of the
          built-in Watcher api. So that usage by developers never have to be
          altered:
             <pre class="inline javascript lang"><code>
this.watch(hungry_catipillar, "in_cocoon", e=> alert('Changes'), [true, [Custom Watcher]]);
        </code></pre>      
        </p>
        <p>
          The requirements are that a <code>static watch()</code> be implemented that
          returns a binding object that can be unwatched via an <code>unwatch()</code>
          method. The watch methods signature will need to support 4 arguments and
          is self explanatory if you study the implementation of the built-in Watcher
          source above:
        <pre class="inline javascript lang"><code>
namespace \`system.drivers.watchers\` (
    class MyCustomWatcher {
        static watch(source_object, prop_name, callback, force){
            ...
            return {
              unwatch : function(){ 
                //remove bindings/listeners and free resourcess
              }
            }
        }
    }
);
        </code></pre>
        </p> 
        <p>
          Finally, the custom watcher should hand back a data object to the callback, with the following
          attributes:
          <table>
            <thead>
              <th>Attributte</th>
              <th>Type</th>
              <th>Description</th>
            </thead>
            <tbody>
              <tr>
                <td>object</td>
                <td>Object</td>
                <td>The original source object being watched</td>
              </tr>
              <tr>
                <td>prop</td>
                <td>String</td>
                <td>The original property name being watched</td>
              </tr>
              <tr>
                <td>old</td>
                <td>Any</td>
                <td>The old value of the property being watched</td>
              </tr>
              <tr>
                <td>val</td>
                <td>Any</td>
                <td>The new value of the property being watched</td>
              </tr>
            </tbody>
          </table>
        </p>
        <p>
          The default Watcher implementation shows this clearly in the <code>data</code> object it maintains. Also
          notice how <code>force</code> is used to fire the binding immediattely.
                  <pre class="inline javascript lang"><code>
namespace \`system.drivers.watchers\` (
    class Watcher {
        static watch(object,prop,cb,force){
            var data = {object, prop, old:object[prop], val:""};
            var _cb = () => {
                data.val=object[prop];
                cb(data);
            }
            object.addEventListener("input", _cb,false);
            object.addEventListener("change",_cb,false);
            force?cb(data):null;
            return {
                unwatch : function(){
                    object.removeEventListener("input", _cb, false);
                    object.removeEventListener("change",_cb, false);
                }
            }
        }
    }
);
        </code></pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>









    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Watchers: usage and syntax</h1>
        <p>
            Data Binding is integrated into WebComponents via a <code>.watch()</code> method with the
            following syntax:
            <pre class="inline javascript lang"><code>
this.watch(some_object, 'a_property', e => a_handler, [force, CustomWatcher]);

//Example: Watch person.firstname for changes
this.watch(person, 'firstname', e => console.log(e.val));
        </code></pre>
        </p>
        <p>
            Where:
            <ul>
                <li><code>some_object</code> - any object, model, element/Node</li>
                <li><code>a_property</code> - self explanatory, but a property of that object</li>
                <li><code>a_handler</code> - a callback that has access to the binding event, <code>e</code></li>
                <li>
                    <code>e</code> - An event passed to callback with what has changed {prop, old, val}
                    <ul>
                        <li><code>prop</code> - the name of the property in this binding</li>
                        <li><code>old</code> - the propertys old value</li>
                        <li><code>val</code> - the propertys new value</li>
                    </ul>
                </li>
                <li>
                  <code>(optional) force</code> - Whether to force a binding immediately. Ottherwise the
                  Watcher is scheduled to fire only after the next change it detects.
                </li>
                <li>
                  <code>(optional) a CustomWatcher</code> - A reference to a class that implements a <code>static watch()</code>
                  method. Defaults to internal <code>system.drivers.watchers.Watcher</code> implementation.
                </li>
            </ul>
        </p>
        <p>
            The above snippet simply logs the new value of <code>person.firstname</code> whenever changes are detected at the member level. A slightly
            more realistic use-case would be to render the changes unto the View in a <code>div</code> tag or a text box:
            <pre class="inline javascript lang"><code>
this.watch(person, 'firstname', e => aDiv.innerHTML = e.val);
        </code></pre>

        <pre class="inline javascript lang"><code>
//old-school functions work too
this.watch(person, 'firstname', function(e) { aDiv.innerHTML = e.val});
        </code></pre>


        <pre class="inline javascript lang"><code>
//As well as Class methods for advanced handling / formatting
this.watch(person, 'firstname', e => this.onFirstNameChanged(e));
        </code></pre>
        </p>

        <p>
            Any object and property could be bound to any object and property, in one direction or both. It does not have to be any particular object. Objects can be elements in the View. Elements can be bound to other elements, or an element to a model. This 1:1 mapping is simple enough to combine in interesting ways.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">1-Way Binding</h1>
        <p>
            Our View has 2 input fields in this example. Since we are able to bind any 2 things together,
            let's bind these in 1-direction, so that when source changes in value, destination will reflect the source and stay synchronized with each other. Code example to the right.
            <view-view-binding bind-type="single">
                <template>
                    <div>
                        <h3>Example 1: View -> View (1-way)</h3>
                        <span style="width:130px;display: inline-block;">SOURCE:</span> <input id="input1"/>
                        <br/>
                        <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input2" disabled/>
                    </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 1: 1-way binding from source to destination elements.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var source = this.querySelector("#input1");
var dest = this.querySelector("#input2");
//bind it
this.watch(source, 'value', e => dest.value = e.val);
        </code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">2-Way Binding</h1>
        <p>
            Here are the same 2 input elements in the View. Let's bind them bi-directionaly so that either one will reflect its value in the other, synchronizing their values.
            <view-view-binding bind-type="both">
                <template>
                    <div>
                        <h3>Example 2: View <-> View (2-way)</h3>
                        <span style="width:130px;display: inline-block;">SOURCE:</span> <input id="input1" value=""/>
                        <br/>
                        <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input2"/>
                    </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 2: 2-way binding from and to source and destination.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var source = this.querySelector("#input1");
var dest = this.querySelector("#input2");
//bind them to each other
this.watch(source,'value', e => dest.value   = e.val);
this.watch(dest,  'value', e => source.value = e.val);
        </code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">1-Way Binding to a Object</h1>
        <p>
            Let's say we have a simple object{} having a firstname property, it's in our Controller. We can bind from this model to the input box in the View the same way.
            <view-view-binding bind-type="both">
                <template>
                    <div>
                    <h3>Example 3: Object -> View (1-way)</h3>
                    <span style="width:130px;display: inline-block;">OBJECT:</span> 
        <pre class="inline javascript lang"><code>
var user = {firstname: "Bill"};
        </code></pre>
                    <br/>
                    <span style="width:130px;display: inline-block;">DESTINATION:</span> <input id="input1" disabled/>
                    <div><em>HINT:</em> try to change <code>user.firstname=</code> in dev console to see view update</div>
                </div>
                </template>
            </view-view-binding>
        </p>
        
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
            <blockquote class="javascript" style="display:block;width: 100%;">
            Example 3: 1-way binding from data model to element(view).
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
var user = {firstname:""};
var dest = this.querySelector("#input1");
//bind them
this.watch(user, 'firstname', e => dest.value = e.val);
</code></pre>

        <blockquote class="javascript" style="display:block;width: 100%;">
            At a later time, we update model (try it in console)
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>//in console
user.firstname = "Ted";</code></pre>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>






    <!-- <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Data Binding is a convenience, but not in todays modern frameworks</h1>
        <p>
            Data Binding is just one strategy for a Controller to synchronize its state with its view. With just one line of code:
          <pre class="inline javascript lang"><code>
this.watch(source, 'value', e => dest.value = e.val);
        </code></pre>
        </p>
        <p>
            We are able to dynamically, and automatically synchronize in real-time, the state (values) of 2 things. Its merely a convenience that can easily be abused because of its simplicity. You don't have this option in most modern frameworks. The frameworks today make binding a fully integrated and central part of it's architecture. This leads to problems.
        </p>
        <p>
            <ul>
                <li><b>Separation of Concerns:</b> Violated. Frameworks today force bindings to be declared in HTML with faux JavaScript fragments littering the View</li>
                <li><b>Readability:</b> The HTML goes from supple and lean, to messy, complex multi-line wrap-arounds, hard to read, hard to understand.</li>
                <li><b>OCP Violation:</b> Most frameworks today lump html, javascript and css into one file or a "Higher Order Function". A small edit might span a few areas, or touching all areas at times.</li>
                <li><b>Performance:</b> Binding is magic. There is a good amount of listeners and polling running on the CPU to check "dirty flags" and keep things mirrored</li>
                <li><b>No Flexibility:</b> Because binding in most frameworks are based on having a model or "prop" types, DOM manipulation isn't easily possible unless you alter the models, a strict form of MVC.</li>
                <li><b>Performance:</b> Due to frameworks constantly monitoring state to render it's view, it leads one to believe that this kind of "loop" runs at some interval, thereby simulating a poor-mans game loop with non-deterministic behavior</li>
                <li><b>Compilation:</b> It's not live. These "faux" bindings in HTML are not native, or semantically meaningful to browsers and must be pre-compiled to generate parsable syntax for the browser.</li>
                <li><b>Debugging:</b> good luck!</li>
            </ul>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div> -->


    
  </div>
</template>





