<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Component Definition</h1>
        <p>
          Components are defined at minimum within a <code>namespace</code> using a class that
          inherits from <code>WebComponent</code>:
          <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    
  }
)
            </code>
          </pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

    

    


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">The Component GUI</h1>
        <p>
          When a component is used on screen (see: <a href="#docs.topics.ComponentUsage">Using Components</a>), it's
          UI will be rendered from an HTML <code>template</code>. By default, the asset files for a component, index.html (<code>template</code>) and index.css (styling), within the components package (folder) are used for rendering a UI -- ensure
          the folder has all 3 assets:
          <ul>
            <li>index.js</li>
            <li>index.html</li>
            <li>index.css</li>
          </ul>

          Here's what the folder/file structure for <code>display.components.ToggleButton</code> should
          look like:
          <project-explorer shadow="true" style="margin: 14px 0px;"></project-explorer>
          <!-- <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    
  }
)
            </code>
          </pre> -->
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Component Template</h1>
        <p>
          Templates are HTML fragments used for the general layout and assembly of elements
          unto the components interface. A typical template is defined in a <code>template</code>
          tag holding a fragment of valid HTML. Here's an example of a components index.html declaration:
          <pre class="inline html lang">
            <code>
&#x3C;template&#x3E;
    &#x3C;div&#x3E;
      &#x3C;button id=&#x22;say_hello&#x22;&#x3E;Hello World&#x3C;/button&#x3E;
    &#x3C;/div&#x3E;
&#x3C;/template&#x3E;
            </code>
          </pre>
          <!-- <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    
  }
)
            </code>
          </pre> -->
        </p>
        <h2>Template Specificity</h2>
        <p>
          There are 3 versatile strategies a component uses at runtime to determine 
          where it's template will come from, this is covered more in the topic, <a href="#docs.topics.ComponentTemplates" class="active">Templating</a>, but we'll briefly
          summarize. 
        </p>

        <h3>Design-time Templates</h3>
        <p>
          The default source is it's index.html asset. But the components template may also be declared, or moved over and placed within the components Class definition itself. These 2 strategies are "design-time" declarations done by the component engineers during package and design. Here's
          the inline <code>template</code> version:
          <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    template(){
      return \`
        &#x3C;template&#x3E;
            &#x3C;div&#x3E;
              &#x3C;button id=&#x22;say_hello&#x22;&#x3E;Hello World&#x3C;/button&#x3E;
            &#x3C;/div&#x3E;
        &#x3C;/template&#x3E;
      \`
    }
  }
)
            </code>
          </pre>
        </p>
        <h3>Runtime-time Templates</h3>
        <p>
          When components are used in normal HTML flow (see: <a href="#docs.topics.ComponentUsage">Using Components</a>), developers have the option of overriding the design-time template and specify
          their own run-time template that takes the highest priority, the component render process will
          ignore all design-time templates and use the inline, runtime <code>template</code> for it's
          UI. Here's an example:


          <pre class="inline html lang">
            <code>
&#x3C;body namespace=&#x22;display.screens.HelloWorld&#x22;&#x3E;
    &#x3C;toggle-button&#x3E;
        &#x3C;template&#x3E;
            &#x3C;div&#x3E;
                &#x3C;span class=&#x22;knob&#x22;&#x3E;&#x3C;/span&#x3E;
            &#x3C;/div&#x3E;
        &#x3C;/template&#x3E;
    &#x3C;/toggle-button&#x3E;
&#x3C;/body&#x3E;
            </code>
          </pre>
        </p>
        <p>
          Alternatively, you may use the <code>src</code> attribute to load the template
          externally, this could perhaps be a web-service or a static PHP/HTML file.
          <pre class="inline html lang">
            <code>
&#x3C;body namespace=&#x22;display.screens.HelloWorld&#x22;&#x3E;
    &#x3C;toggle-button src=&#x22;src/display/components/ToggleButton/custom-template_2.html&#x22;&#x3E;&#x3C;/toggle-button&#x3E;
&#x3C;/body&#x3E;
            </code>
          </pre>
        </p>
        <h3>Template Specificity Table</h3>
        <p>
          Render order is from <b>grestest (3)</b> strength choice to <b>least (0)</b> fallback.
          <table>
              <thead>
              <tr>
                <th>Specificity</th>
                <th style="width: 106px;">Type</th>
                <th style="width: 200px;">Source</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>3</td>
                <td>Runtime</td>
                <td>HTML Inline <code>template</code></td>
                <td>Template is inlined during usage</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Runtime</td>
                <td>HTML <code>src</code> attribute</td>
                <td>Externally loaded during usage</td>
              </tr>
              <tr>
                <td>1</td>
                <td>Design-time</td>
                <td>JavaScript <code>template()</code></td>
                <td>Template found in components JavaScript Class definition</td>
              </tr>
              <tr>
                <td>0</td>
                <td>Design-time</td>
                <td><code>index.html</code> asset file</td>
                <td>Template found in components asset folder as index.html</td>
              </tr>
            </tbody>
          </table>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>







    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Component Stylesheets</h1>
        <p>
          Component styling is unlike the components <code>template</code> specificity. Since
          CSS has built-in specificity due to it's additive nature and style inheritance,
          engineers may package the stylesheet of a component at design-time using the
          external index.css asset file or within the Component class via the <code>cssStyle()</code>
          function or both. In addition, extra stylesheets can be loaded in combination, giving
          good flexibility but will be confusing. You should generally design components to use
          styling from JavaScript, using <code>cssStyle()</code> OR let the component fall-back to loading it's default index.css asset.
        </p>
        <p>
          Here's an example of declaring the stylesheet within the Components class definition using 
          the <code>cssStyle()</code> function:
          <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    cssStyle(){
      return \`
        :host {
          display:block;
          font-size:12px;
          color:red;
        }

        :host span {
          border:1px solid black;
        }
      \`
    }
  }
)
            </code>
          </pre>
        </p>
        <p>
          When <code>cssStyle()</code> is not used, the component will fall-back to it's external index.css
          stylesheet similar to how it falls back to it's <code>template</code> in index.html as the lowest
          priority.
        </p>
        <p>
          Here's an example of a stylesheet from a components index.css asset file. NOTE: Do not
          wrap the css rules in a <code>style</code> tag.
            <pre class="inline css lang">
            <code>
:host {
  display:inline-block;
  width: 142.85px;
  height: 99px;
  background-image: url("docs/images/goblin.png");
}

/* sprite stance animation */
:host .stance {
  animation: stance steps(7) 1.4s infinite;
}
            </code>
          </pre>
        </p>
        <h3>Loading Additional Stylesheets</h3>
        <p>
          Additional stylesheets may also be specified using the <code>@stylesheets</code> decorator, see 
          <a href="#docs.topics.JavascriptDecorators" class="active">Decorators</a>. An array
          of .css paths is supported:
          <pre class="inline javascript lang">
            <code>
@stylesheets(["resources/css/common.css"]);
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {
    cssStyle(){
      return \`
        :host {
          display:block;
          font-size:12px;
          color:red;
        }

        :host span {
          border:1px solid black;
        }
      \`
    }
  }
)
            </code>
          </pre>
        </p>
        <h3>Inline Stylesheets</h3>
        <p>
          Additionally, inline stylesheets could be loaded at design-time within
          the design-time template using either the <code>&#x3C;link&#x3E;</code> or 
          <code>&#x3C;style&#x3E;</code> tags or a combination of both:
          <pre class="inline html lang">
            <code>
&#x3C;template&#x3E;
    &#x3C;link rel=&#x22;stylesheet&#x22; type=&#x22;text/css&#x22; href=&#x22;/resources/css/common.css&#x22; /&#x3E;
    &#x3C;style&#x3E;
       .ToggleButton {
           color:red;
       }
    &#x3C;/style&#x3E;
    &#x3C;div&#x3E;
      &#x3C;button id=&#x22;say_hello&#x22;&#x3E;Hello World&#x3C;/button&#x3E;
    &#x3C;/div&#x3E;
&#x3C;/template&#x3E;
            </code>
          </pre>
        </p>
        <p>
          Again, you'll want to avoid loading multiple stylesheets using the various approaches
          above in combination, as this will lead to specificity problems that are hard to debug. <em>Also, I recommend against using <code>&#x3C;link&#x3E;</code> or inline <code>&#x3C;style&#x3E;</code>
          tags as shown above for Components. Either let the fallback (index.css) or <code>cssStyle()</code> be loaded.</em>
        </p>
        <h3>Contextual <code>:host</code> styling</h3>
        <p>
          <em>As a recommendation, always prefix styling rules for the component using <code>:host</code>.</em>
          This alleviates the problems of CSS clashing and the specificity nightmares outlined in the chapter , <a href="#docs.topics.CascadingStylesheets">Common Styling Problems</a>
        </p>
        <h3>Stylesheet Lifecycle</h3>
        <p>
          The components stylesheet transitions through a life-cycle in several stages during load/render, see the chapter, <a href="#docs.topics.StyleSheets">Stylesheet life-cycle</a> to understand the process and
          some interesting transformations that can be applied, like parsing LESS into CSS att runtime.
        </p>
        <h3>Disable Stylesheet Loading</h3>
        <p>
          Finally, component engineers may want to disable any external stylesheets from being loaded during design-time. Maybe the <code>cssStyle()</code> function will be the sole source of styling, this can
          be used as an optimization technique for faster rendering. Override the <code>onLoadInstanceSstylesheet()</code> hook and return false, this prevents any fallback/external .css files from loading.
          <pre class="inline javascript lang">
            <code>
namespace \`display.components\` (
  class ToggleButton extends WebComponent  {

    onLoadInstanceSstylesheet(){ return false }

    cssStyle(){
      return \`
        :host {
          display:block;
          font-size:12px;
          color:red;
        }

        :host span {
          border:1px solid black;
        }
      \`
    }
  }
)
            </code>
          </pre>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Component Usage</h1>
        <p>
          Now that a component is defined (design-time) let's look at the
          various ways it can be used natively according to the W3C specs,
          read about <a href="#docs.topics.ComponentUsage">Using Components</a>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

  </div>
</template>