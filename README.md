# Description
The Arc Engine is a W3C-compliant, ES6/7 Component Framework (not an api) used
for building enterprise grade applications and ui controls. It adheres to the 
WebComponent Specification for crafting Autonomouse Reactive Components (Arc)
in pure, vanilla JavaScript, HTML5 and CSS3.

- [Website](https://www.arc2d.com)
- [Documentation](https://www.arc2d.com/resources)
- [Demos - Sandbox In Progress]()
    - [Hello World](https://www.arc2d.com/resources/?path=docs/topics/HelloWorldSimple)
 

# Why
Arc differs significantly at both language and architectural aspects when compared to other frameworks
such as Angular, VUE, React and so on:
- No Compilers, Dependencies
- W3C Components
- A Meta-Framework
- Class Driven Definitions
- Namespaces
- Inheritance
- Visual Inheritance
- Components (prefabs)
- World Simulation
- Composition & Nesting for Screen Assembly

# No Compilers, Dependencies
The Arc Engine is installed into the ```HEAD``` of any existing webpage in one line:
```html
<script src="https://cdn.jsdelivr.net/gh/nashorn/od-cocoon@latest/framework.min.js" charset="utf-8"></script>
```
There are NO compilers, pre or post processing runs. No Webpack, Snowpack, Rollup or “Build” tasks. No Babel, Grunt, Browserify or 'Tree Shaking'. There are no 3rd party api's, npm's or plugins of any kind. You do not need a package.json unless required and zero cli tool requirements. So how does it work?


# W3C Components
- [Defining Components](https://www.arc2d.com/resources/?path=docs/topics/DefineComponent)
- [Using Components](https://www.arc2d.com/resources/?path=docs/topics/ComponentUsage)
- [Component LifeCycle](https://www.arc2d.com/resources/?path=docs/topics/ComponentLifecycle)


# A Meta Framework
Arc is a self-interpreted meta framework architecture that transpiles minimistically on-the-fly and just-in-time. Zero-config setup means it runs on default settings. No compilers or processors completely eliminate extra toolchains. Your ```src/``` directory remains purely native ES6, absolutely no TypeScript. The ```node_modules``` folder, almost empty. The Arc platform is 100% native EcmaScript and self-executing, self-interpreting even in the console.

Being a meta-framework, Arc is able to run itself, the base framework, cocoon, as an application on it's own. Though it has no meaning and will not affect or do anything special to a webpage, it is able to run as an instance of itself. 2nd, being a meta-framework, developers will be able to craft new types of engines on top of arc (cocoon). Think of ```cocoon``` as the Linux kernel.


# Class Driven Design
Instead of 'higher-order' functional programming concepts, as used in React, Arc
relies on 3rd generation class driven aspects of the latest ES6/7 language, keeping the affordance of powerful features found in modern Java/C++ and C#. In Arc, native classes are used to define Autonomous Reactive Components based on the W3C specification for custom element definition:

```javascript
class ToggleButton extends Component {

}
```


# Namespace
- [Component Namespaces In Depth](https://www.arc2d.com/resources/?path=docs/topics/ComponentNamespaces)

1st, Arc runs in an isolated scope, there are no private/public variables that are leaked into the window except for a handful, such as the ```Component``` Class which is submissive, allowing any 3rd party domainating library to have it's way. 2nd, namespaces categorize classes from collision and serves as aliases to the public Class. There are no compilers used to allocate namespaces, they are live and direct and runnable from the browser console.

```javascript
namespace `org.ui`
    class ToggleButton extends Component {

    }
);

//accessible at
org.ui.ToggleButton
```

In the event that Arcs ```Component``` class cannot be used because a 3rd party api is clobbering the global scope, you are free to leverage Arc's namespace to Component, ```core.ui.WebComponent```:
```javascript
namespace `org.ui`
    class ToggleButton extends core.ui.WebComponent {

    }
);
```


## Usage:

```new``` Constructor Usage:
```javascript
var toggle = new org.ui.ToggleButton;
document.body.appendChild(toggle)
```

```createElement``` Usage:
```javascript
var toggle = document.createElement("org-ui-toggle-button");
document.body.appendChild(toggle)
```

Declarative ```HTML``` Usage:
```html
<body>
    <org-ui-toggle-button></org-ui-toggle-button>
</body>
```
Tag names are auto-generated by Arc based on the components unique ```namespace```. The Web Component spec is respected, having at minimum 2 words separated by dashes but takes it a step further by guranteeing unique tagNames.

# Inheritance
Arc leverages inheritance for codifying the semantic gnome within a family of Classes having taxonomic, prototypal similarities. The argument of "inheritance vs. composition" is one based on a lack of experience and wisdom of key differences, or blissful ignorance. While inheritance preserves lineage and traits of common ancestry within a family, composition is the structural coupling of concrete instances through assembly of objects taken from across family trees. In either case, there is code sharing, but this is a side effect of design, not the core purpose of "inheritance vs. composition", of which both ideologies are intrinsically established and used in the Arc Engine platform.

```javascript
namespace `demos.ui`
    class Button extends Component {
        constructor(){
            super();
        }
    }
);
```

```javascript
import 'demos.ui.Button';

namespace `demos.ui`
    class ToggleButton extends demos.ui.Button {
        constructor(){
            super();
        }
    }
);
```


# Traits
Share common traits & charastics across Class hierarchies.
```javascript
class Observer {}

class FileWriter {}

namespace `core.utilities` (
    class Logger extends Object.with(Observer, FileWriter) {
        //has features from Observer + FileWriter
    }
)
```


# Visual Inheritance
When components inherit from other components in Arc, the subclassed component will be identical to it's ancestor in terms of traits, behavior and *visual appearance*, a guarded trade secret in the Arc Engine. In the example that follows, ```SwitchButton``` will be an exact blueprint of ```ToggleButton``` so that if an instance of each,
Switch and Toggle were placed on the page, you would not be able to distinguish a visual or behavioural difference.

Arc's internal encrypted Helix Engine preserves the visual appearance up to the parent class and all of the ancestors of the parent in the prototype chain so that every sub-class down the chain will reflect the visual aspects of every one of its ancestors. A truely unprecedented framework characteristic not found anywhere else, in any other api or framework on earth, we stake the claim as a competetive advantage. 

Pay notice, that css/styling, scoping or 'BEM' rules is not imported anywhere. See the docs for details.

```javascript
namespace `demos.ui`
    class ToggleButton extends Component {
        
    }
);
```

```javascript
import 'demos.ui.ToggleButton';

namespace `demos.ui`
    class SwitchButton extends demos.ui.ToggleButton {
        
    }
);
```


# Components
Components in Arc are pre fabricated (prefabs) packages, where every component is packaged into it's own portable namespaced folder. Each folder holds 3 core assets per component:
- index.js
- index.css
- index.html

React crosses the spearation of concerns boundary and intertwines these into 1 file and not only the mixing of the triad but a defilement, where HTML is no longer interpretable by the DOM without a JSX compiler, CSS is bound to state and no longer CSS without Reacts compiler, and Javascript having a mixture of all and not really JavaScript without build tools and a reinvented Virtual DOM.

Instead of a reinvented 'Virtual DOM', Arc is close-to-the-metal, handing off all work to the native DOM, leveraging the full potential of the Browsers render engine. Speed, Performance and Lite weight. Arc allows a hybrid approach though, where these native technologies in the triad (html, css) can be left separate or inlined into the Components Class for lightening fast load & render times, or even automated to be stitched into a single compressed runtime.



# World Simulation
Arc is natively an event-driven architecture, the event loop. User interaction (clicks, taps) triggers event handler callbacks. But there is also a World environment that steps at 60fps using in a "game loop" for time-sensitive fixed updates, relevant to AI, Physics, 2D and 3D simulations. Similar to Unity, Arc's input-update-render game loop is implemented using:
- ```onUpdate``` - running once per frame for input, state changes
- ```onFixedUpdate``` - running multiple times at a fixed delta per frame for collisions, ai
- ```onDraw``` - running once per frame for painting

```javascript
import '@domain.models.Clock';

namespace `ui.components` (
    class AnalogClock extends Component {
        constructor(){
            super();
            this.model = new domain.models.Clock; //a model of clock
        }

        //runs many times per frame (physics/ai) at 8.333ms intervals. 
        onFixedUpdate (time) {}

        //runs once per frame (handle input/state updates) @16ms-24ms
        onUpdate(timestamp, delta){
            this.model.onUpdate();
        }

        //runs once per frame AFTER onUpdate, (handle interpolation for fps-drop or lag) @16ms-24ms
        onDraw(interpolation){
            this.hour.style.transform   = `rotate(${this.model.hour}deg)`;
            this.minute.style.transform = `rotate(${this.model.minutes}deg)`;
            this.second.style.transform = `rotate(${this.model.seconds}deg)`;
        }
    }
);



//The application (World)
import 'ui.components.AnalogClock';

namespace `ui.worlds` (
    class ClockApp extends World {
        async onConnected(){
            await super.onConnected();
            this.clock = this.querySelector("ui-components-analog-clock")
        }
        onUpdate =(timestamp, delta)=> {
            this.clock.onUpdate()
        }

        onFixedUpdate =(time)=> {
            this.clock.onFixedUpdate()
        }

        onDraw =(interpolation)=> {
            this.clock.onDraw()
        }
    }
);
```

```html

<!-- html shell page, "clock.html" -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Arc Engine : Analog Clock @60fps</title>
        <script src="https://cdn.jsdelivr.net/gh/nashorn/od-cocoon@latest/framework.min.js" charset="utf-8"></script>
    </head>

    <body namespace="ui.worlds.ClockApp">
        <splash-loader shadow></splash-loader>
        <ui-worlds-clock-app></ui-worlds-clock-app>
    </body>
</html>
```