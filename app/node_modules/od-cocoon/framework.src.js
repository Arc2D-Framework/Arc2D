Session = top.Session||{State:{}};
Config = window.Config||{
    SRC_PATH:"src/",
    ENVIRONMENT:"prod",
    ROOTPATH : "./",
    LOGGING:true,
    DYNAMICLOAD:true,
    FILENAME:"index.*js",
    ENABLE_TRANSPILER : true,
    NAMESPACE : "applications.MainApp"
};


var $framework = {
	stable : "3.0.4",
	nightly : "3.1.0",
	current: "3.1.0",
	
	description: ""
}

//--------EXTENSIONS---------
//
//

if(!String.prototype.toDomElement){
    String.prototype.toDomElement = function(){
      var n = document.createRange().createContextualFragment(this.toString())
      return n.firstElementChild;
    }
};

//
//
//
if ("LOGGING" in Config && Config.LOGGING != true) {
    for (var k in console) {
        console[k] = function () { };
    }
}

window.getParameterByName = function (name, url) {
    var match = RegExp("[?&]" + name + "=([^&]*)").exec(
        url || window.location.href
    );
    return match && decodeURIComponent(match[1].replace(/\+/g, " "));
};

window.toAbsoluteURL = function(url) {
    const a = document.createElement("a");
    a.setAttribute("href", url);
    return a.cloneNode(false).href; 
}
//TDOD: Not returning what i expected, a class ref
//ex, classof `core.drivers.storage.Memory`;
window.classof = function(ns){
    return NSRegistry[ns];
}


window.imported_classes = window.imported_classes || {};
window.imports = async function (x, opts, isError) {
    opts = opts || { cache: Config.IMPORTS_CACHE_POLICY || "no-store" };
    return new Promise(async (resolve, reject) => {
        var path = x;
        path = path.replace(/^\/+/, Config.ROOTPATH);
        var error = "404 import: " + toAbsoluteURL(path)||path;

        if (window.imported_classes[x]) {
            resolve(window.imported_classes[x]);
            return;
        }

        try {
            const response = await fetch(path, opts);
            if (response.ok) {
                const res = await response.text().then(src => {
                    window.imported_classes[x] = src;
                    resolve(src);
                });
            } else {
                //then()-else{} when ran from server. catch() block never runs
                var src = await response.text();
                console.error(error);
                resolve(null);
            }
        } catch (e) {
            var request = new XMLHttpRequest();
            request.open('GET', path, false);
            request.send(null);

            if (request.status == 0 || request.status == 200) {
                src = request.responseText;
                window.imported_classes[x] = src;
                resolve(src);
            }
        }
    });
};


//-----------LIBS------------
function transpile(target, level){}

function stylesheets (target, paths){
    function relativeToAbsoluteFilePath(path, ns, appendRoot){
        ns = ns||this.namespace;
        ns = ns.replace(/\./gim,"/");
        if(path.indexOf("/./") >= 0){
            path = path.replace("./", ns+"/");
        } 
        path = /http:/.test(path)? path : path.replace("//","/");
        return path;
    }
    paths && paths.forEach(p => {
        var filepath = relativeToAbsoluteFilePath(p,target.prototype.namespace,false);
        target.prototype['@stylesheets'] = target.prototype['@stylesheets']||[];
        target.prototype['@stylesheets'].push(filepath)
    })
}
window.stylesheets = stylesheets;

function traits(target, __traits){
	var inheritTraits = function(klass, properties){
        properties = properties.reverse();
        properties.forEach(trait => {
            if (typeof trait == "object") {
                defineProps(klass, trait)
            }
        });
    };
    
    var defineProps = function(proto, trait){
        for (var prop in trait) {
            if(!proto[prop]){
                Object.defineProperty(proto,prop,{
                    value : trait[prop],
                    writable:true
                })
            }
        }
    }
    
	inheritTraits(target.prototype, __traits);
};
window.traits = traits;

function cascade(target,shouldCascade){
	target.prototype['@cascade'] = shouldCascade;
}
window.cascade = cascade;

function prop(target,key,val){
	target.prototype[key] = val;
}
window.prop = prop;



function tag(target, name){
    target.prototype["ns-tagname"]=name;
    try{window.customElements.define(name, target);}catch(e){}
    return;
}
window.tag = tag;


function field(target, type, key, val){
    target = (type=="static") ? 
        target:
        target.prototype;
    target[key] = val;
}
window.field = field;


; (function(env) {
    env.NSRegistry = env.NSRegistry||{};
    
    env.namespace = function(ns){
        ns = ns[0];
        return function(...defs){
            defs.forEach(def => {
                def=def||{};
                var nsparts=ns.match(/\.([A-Z]+[a-zA-Z0-9\_]*)\b$/);
                var k = def.prototype||def;
                    k.classname = nsparts?nsparts[1]:def.name;
                    var fns = ns+"."+k.classname;
                    k.namespace = fns;
                env.NSRegistry[fns] = createNS(fns,createClass(def||{}));
                return env.NSRegistry[fns]
            })
        }
    }
    
    var createNS = function(aNamespace, def){
        var parts       = aNamespace.split(/\./g); 
        var classname   = parts.pop();
        var scope = parts.reduce((acc, next) => acc[next] ? 
            acc[next] : (acc[next]={}), env);
        scope[classname] = def;
        return scope[classname];
    };

    var createClass = function(func){
        try {
            var proto  = func.prototype;
                proto.ancestor = proto.__proto__.constructor;
                try{  func.define(proto) }catch(e){};
                return func;
        } catch(e){ return func }
        return func
    };
})(window);


//------------UI-------------

namespace `core.ui.templating` (
    class CustomTemplateEngines {
        constructor(){
            this.engines = {}
            this.defaultMimetype = Config.DEFAULT_TEMPLATE_ENGINE_MIMETYPE||"template/literals";
        }

        define(mimeType, engine){
            if(!this.engines[mimeType]){
                this.engines[mimeType] = engine;
                engine.install();
            }
        }

        getEngineByMimeType(mime){
            return this.engines[mimeType];
        }

        get default (){
            return this.engines[this.defaultMimetype];
        }

        set default (mimeType){
            this.defaultMimetype = mimeType;
        }
    }
)

window.customTemplateEngines = new core.ui.templating.CustomTemplateEngines;



(() => {
    var TemplateLiterals = {
        name : "TemplateLiterals",
        ext : ".es6",
        eval : function(tempStr, data, self){
            var parse = (tempStr, templateVars) => {
                return new Function("return `"+tempStr +"`;").call(templateVars);
            }
            return parse(tempStr, data)
            // return eval('`'+tempStr+'`');
        },
        isAvailable : function(){
            return true
        },

        install : function(){
            // console.log("TemplateLiterals template engine installed successfully.")
        }
    };

    window.customTemplateEngines.define("template/literals", TemplateLiterals);
})();



namespace `w3c.ui` (
    class WebComponent extends HTMLElement {
        constructor() {
            super();
            this.__proto = this.constructor.prototype;
            this.root = this.onEnableShadow() ? 
                this.attachShadow({ mode: 'open' }) : this;
        }

        static define(proto,bool){
            var tag = proto.classname.replace(/([a-zA-Z])(?=[A-Z0-9])/g, (f,m)=> `${m}-`).toLowerCase();
            if(/\-/.test(tag)){
                proto["ns-tagname"] = tag;
                this.defineAncestors();
                this.defineAncestralClassList();
                try{window.customElements && window.customElements.define(tag, this);}
                catch(e){console.error(e)}
            }       
        }

        setStylesheet () {    
            var css = this.cssStyle();
            !!css && !this.__proto._style_defined ? 
                (this.appendStyleSheet(
                    `<style type="text/css" rel="stylsheet">\n${css}\n</style>`.toDomElement()), 
                    this.__proto._style_defined=true
                ) : null;
        }

        //TODO: Revisit how to make it work wihout passing deep flag
        querySelector(cssSel, e){
            if(e){
                return this.getParentNodeFromEvent(e,cssSel)
            } else {
            return this.onEnableShadow() ?
                this.root.querySelector(cssSel):
                super.querySelector(cssSel)
            }
        }

        querySelectorAll(cssSel, deep){
            return this.onEnableShadow() ?
                this.root.querySelectorAll(cssSel):
                super.querySelectorAll(cssSel)
        }

        appendStyleSheet(stylesheet) {
            if(this.onEnableShadow()){
                try{
                    var style = new CSSStyleSheet();
                    style.replace(stylesheet.innerText);
                    this.root.adoptedStyleSheets = [stylesheet]
                } catch(e){
                    console.error(`${e.message} Unable to adopt stylesheet 
                        into shadow dom -- ${this.namespace}#appendStyleSheet(), 
                        see: https://bugzilla.mozilla.org/show_bug.cgi?id=1520690.
                        As a workaround, @import the css from within <template>`)
                }
            }
            else {
                var headNode = application.head;
                var configscript = application.configscript;
                headNode.insertBefore(stylesheet, configscript);
            }
        }

        adopts(orphan) {
            orphan && orphan.parentNode.replaceChild(this, orphan)
            orphan && this.appendChild(orphan);
        }

        replaces(orphan) {
            orphan && orphan.parentNode.replaceChild(this, orphan);
        }

        dispatchEvent(type, data, details = { bubbles: true, cancelable: true, composed: true }, element = this) {
            var evt = new CustomEvent(type, details);
            evt.data = data;
            return super.dispatchEvent(evt);
        }


        //TODO: refactor to return a Binding that can be enabled/disabled.
        bind(el, evtName, handler, bool=false) {
            var self = this;
            if (typeof el == "string") {
                this.addEventListener(evtName, e => {
                    var t = this.getParentNodeFromEvent(e, el);
                    if (t) {
                        handler({
                            target: t,
                            realtarget: e.target,
                            src: e,
                            preventDefault: () => e.preventDefault,
                            stopPropagation: () => e.stopPropagation
                        });
                    }
                }, bool);
            } else {
                el.addEventListener(evtName, handler, bool);
            }
        }

        getParentBySelectorUntil(elem=this, terminator="html", selector) {
            var parent_node = null;
            do {
                if(elem.matches(selector)){
                    parent_node = elem;
                    break;
                }
                if(elem.matches(terminator)){
                    break;
                }
                elem=elem.parentNode;
            } while(elem && elem.matches) 

            return parent_node;
        }

        getRealTargetFromEvent(e,selector, terminator) {
            console.warn(`DEPRECATED: ${this.namespace}.getRealTargetFromEvent() - use getParentNodeFromEvent()`);
            return this.getParentNodeFromEvent(e, selector, terminator)
        }

        getParentNodeFromEvent(e, selector, terminator) {
            var el = e.composedPath()[0];
            return this.getParentBySelectorUntil(el, terminator, selector);
        }

        onStylesheetLoaded(style) { }

        cssTransform(css) {
            var ns = this.namespace;
            css = css.replace(/resource\([\'\"]?([^\'\"]*)[\'\"]?\)/mg,
                (full, m1) => "url(" + this.resourcepath(m1, ns) + ")"
            );
            return css;
        }

        setCssTextAttribute(_cssText, stylenode) {
            if (stylenode && stylenode.styleSheet) {
                stylenode.styleSheet.cssText = _cssText;
            }
            else {
                stylenode.appendChild(document.createTextNode(_cssText));
            }
        }


        async loadTemplate() {
            return new Promise(async (resolve, reject) => {
                var tem  =  this.querySelector("template")||    //node
                            this.src||                          //uri
                            this.template()||                   //string
                            "/src/./index.html"                 //default
                
                if(/\/*\.html$/.test(tem)){
                    var src=this.src||tem;//TODO: bug here?
                    var opts = { cache: "force-cache" };
                    src = src.replace("/./", "/" + this.namespace.replace(/\./gim, "/") + "/");
                    this._template = await imports(src, opts);
                }
                else if(/<\s*\btemplate\b/.test(tem)){//from inner template()
                    this._template=tem;
                }
                else if(tem && tem.nodeType==1){
                    this._template=tem.outerHTML;
                }
                resolve(this._template);
            })
        }


        onConnected() { }

        render(data) {
            data = data || {};
            data.component = this;
            var t = this._template;
            if (t) {
                var html = this.evalTemplate(t, data || {});
                var temNode = html.toDomElement();
                temNode = temNode.content;
                if (!this.onEnableShadow()) {
                    this.slots.forEach(slot => {
                        var slotName = slot.getAttribute('slot');
                        var placeholder = temNode.querySelector(`slot[name="${slotName}"]`);
                        if( placeholder){
                            if(!placeholder.hasAttribute("append")){
                                placeholder.innerHTML="";
                            }
                        }
                        (placeholder||temNode).appendChild(slot)
                    })
                }
                this.root.innerHTML = "";
                this.root.appendChild(temNode);
                this.onTemplateRendered(temNode);
            }
        }

        async connectedCallback() {
            if( this._is_connected){return;}
            this._is_connected=true;
            var html = await this.loadTemplate();
            this.onTemplateLoaded();

        }

        onTemplateLoaded() {
            this.slots = this.getSlots();
            this.setClassList();
            this.setPrototypeInstance();
            this.setStyleDocuments();
            this.onConnected();
        }


        getSlots() {
            return Array.from(this.children)
        }


        onTemplateRendered(){
            this.initializeChildComponents();
        }
        
        static get observedAttributes() {
            return ['src'];
        }

        get src() {
            return this.getAttribute('src');
        }

        set src(val) {
            this.setAttribute('src', val)
        }

        onEnableShadow() {
            return this.hasAttribute('shadow');
        }

        attachShadow(options) {
            this._usesShadow = true;
            return super.attachShadow(options);
        }


        async attributeChangedCallback(name, oldValue, newValue) {
            if (name == "src"){
                if(!this._is_connected){return;}
                else {
                    var html = await this.loadTemplate();
                    this.onConnected()
                }
            }
        }


        cssStyle(){return ""}

        setStyleDocuments() {
            this.loadcss(this.getStyleSheets());
            this.setStylesheet();
        }

        static defineAncestors(){
            this.ancestors=[];
            var a=this;
            while(a && this.ancestors.push(a)){
                a = a.prototype.ancestor;
            }
        }

        static defineAncestralClassList(){
            this.prototype.classes = [];
            for(let ancestor of this.ancestors){
                var proto = ancestor.prototype;
                if( proto['@cascade']||ancestor==this){
                    this.prototype.classes.unshift(proto.classname)
                } else { break }
            }
        }

        setClassList() {
            this.className += this.className + (" " + this.constructor.prototype.classes.join(" ")).trim()
        }

        getStyleSheets() {
            return (this["@stylesheets"]||[]).reverse();
        }




        async loadcss(urls) {
            urls=urls.reverse();
            var stylesheets = window.loaded_stylesheets = window.loaded_stylesheets|| {};
            for(let path of urls){
                if(!stylesheets[path]){
                    var tagName = /^http/.test(path) ? "link" : "style";
                    var tag = document.createElement(tagName);
                        tag.setAttribute("type", 'text/css');
                        tag.setAttribute("rel",  'stylesheet');
                        tag.setAttribute("href",  path);
                        tag.setAttribute("component", this.namespace);
                        stylesheets[path] = tag;
                        if(tagName.toLowerCase() == "style"){
                            var _cssText = await window.imports(path);
                                _cssText = this.cssTransform(_cssText);
                                this.setCssTextAttribute(_cssText, tag);
                                this.onStylesheetLoaded(tag);
                        }
                        this.appendStyleSheet(tag);
                }
            }
        }


        template(){return null}

        //TODO: new proposal for simpler use and DIP
        evalTemplate(template, data) {
            var eng = this.getTemplateEngine();
            return eng.eval(template, data, this);
        }

        getTemplateEngine() {
            return window.customTemplateEngines.default;
        }

        setPrototypeInstance() {
            this.setAttribute("namespace", this.namespace);
            this.prototype = this;
        }


        resourcepath(url, ns){
            url = url.replace(/\$\{ns\}/gm, ns.replace(/\./gim,"/"));
            return Config.ROOTPATH + url;
        }

        initializeChildComponents (el){
            el = el||this;
            var self=this;
            var nodes = this.querySelectorAll("*");
                nodes = [].slice.call(nodes);
                nodes.forEach(n => {
                    if(n && n.nodeType == 1) { 
                        var tag = n.tagName.toLowerCase();
                        var c = window.registered_tags[tag];
                        c&&c.define(c.prototype,true);
                    }
                })
        }
    }
);


namespace `w3c.ui` (
    class ProtectedComponent extends w3c.ui.WebComponent {
        constructor(el){
            super(el);
        }

        static define(proto, bool){
        	if(!bool){return}
            super.define(proto);      
        }
    }
);
;
(() => {
   //NO PATCHES YET, BUT THEY GOES HERE
})()
;


;

namespace `w3c.ui` (
	class Application extends w3c.ui.WebComponent {
	    constructor(element) {
	        super(element);
	        window.application = this;
	        this.head           = document.getElementsByTagName("head")[0];
	        this.configscript   = document.querySelector("script[id='config']")||
	                              document.querySelector("script");
	    }


	    static define(proto, bool=true){
            super.define(proto,bool);      
        }

	}
);


//--------BOOTLOADER---------
function Ecmascript6ClassTranspiler() { }
Ecmascript6ClassTranspiler.prototype.imports = window.imports;
Ecmascript6ClassTranspiler.prototype.transpile = function (src, doc) {
    var doTranspile = Config.ENABLE_TRANSPILER;
    if (doTranspile) {
        src = this.transpileToLevel(src);
        return src;
    } else {
        return src;
    }
}

Ecmascript6ClassTranspiler.prototype.transpileToLevel = function (src) {
    var nsReg = /namespace\s?`([^\s`]*)/;
    var clsReg = /class\s+([^\s]*)\s+[\{|extends]/;

    var nsMatch = src.match(nsReg);
    var classMatch = src.match(clsReg);
    if(!nsMatch && !classMatch){
        return this.transipleImportsDestructuring(src);
    }
    else {
        nsMatch = nsMatch ? nsMatch[1] : "";
        classMatch = classMatch?classMatch[1]:"";
        nsMatch = nsMatch + "." + classMatch;
        src = this.transipleDecoratorFields(nsMatch, src);
        src = this.transipleClassFields(nsMatch, src);
        src = this.transipleImportsDestructuring(src);
        return src;
    }
}

Ecmascript6ClassTranspiler.prototype.transipleDecoratorFields = function (ns,src) {
    //   var regex = /@([^\s]*)\({1}([^\;]*)\){1};{1}/gm; //<--works but not for @matchmedia
    var regex = /@([^\W]*)\({1}([^\;]*)\){1};{1}/gm; //Feb 7 2019 - to support @matchmedia queries having ('s)
    var props = [];
    if (ns) {
        src = src.replace(regex, (full, method, args) => {
            props.push(`${method}(${ns}, ${args});`);
            return "";
        });
        var fullsrc = src + "\n" + props.join("\n");
    } else {
        src = src.replace(regex, (full, method, args) => {
            return "";
        });
        fullsrc = src;
    }
    return fullsrc;
}

Ecmascript6ClassTranspiler.prototype.transipleImportsDestructuring = function (src) {
    var regex = /import\s\{([^\}]*)\}\sfrom\s([^;]*)/gm;
    src = src.replace(regex, (full, destructured_var, src_path) => {
        destructured_var = destructured_var.replace(/\s+as\s+/gm, ":");
        return `var {${destructured_var}} = (()=> {\nimport ${src_path};\n})();`;
    });
    src = src.replace("export", "return");
    return src;
}

Ecmascript6ClassTranspiler.prototype.transipleClassFields = function (ns, src) {
    var regex = new RegExp(
        /(\@static|@public|\@private)\s+([^\s]*)\s+\=([^\;]*)\;/gm
    );
    var props = [];

    if (ns) {
        src = src.replace(regex, (full, type, name, val) => {
            type = type.replace("@", "");
            props.push(`field(${ns}, "${type}", "${name}", ${val});`);
            return "";
        });
        var fullsrc = src + "\n" + props.join("\n");
    } else {
        src = src.replace(regex, (full, type, name, val) => {
            return "";
        });
        fullsrc = src;
    }
    return fullsrc;
}

namespace `core.http` (
	class ResourceLoader {
    	constructor (){ return this; }
	}
);




namespace `core.http` ( 
    class ClassLoader extends core.http.ResourceLoader {

        constructor (){
            super();
            this.es6Transpiler = new Ecmascript6ClassTranspiler();
            window.run=this.run.bind(this);
            return this;
        }

        run(src,cb){
            this.build(src, output => {
                var head   = document.getElementsByTagName("head").item(0);
                var script = document.createElement("script");
                script.setAttribute("type", "text/javascript");
                script.setAttribute("charset", (Config.CHARSET || "utf-8"));
                script.text = output;
                head.appendChild(script);
                cb(script);
            });
        }

        async load (_namespace,filepath, cb) {
            var self=this;
            var self = this;
            var src;
            var cfFailure = function(src, xhr){
                cb?cb(xhr):null;
            }

            var src;
            if(filepath) {
                src = await window.imports(filepath)
            }
            // else {
            //     var paths_to_try = es6Transpiler.pathsToTry(_namespace);
            //     src = await es6Transpiler.imports(paths_to_try[0],false)||
            //           await es6Transpiler.imports(paths_to_try[1],false);
            // }

            src?this.run(src,cb):cfFailure(src,"no xhr");   
        }



        async build(src, cb) {
            src = this.es6Transpiler.transpile(src);
            var reg = /^import\s+[\'\"]{1}([^\'\"]*)[\'\"]{1}\;?/m;

            while (reg.test(src)) {
                var ns_or_path = src.match(reg)[1];
                var s = (window.imported_classes[ns_or_path] ?
                        ";" : await window.imports(ns_or_path))||"";
                s = s ? this.es6Transpiler.transpile(s) : "";
                src = src.replace(reg, s);
            }
            src = `(()=>{ ${src} })()`;
            cb(src);
        }
    }
);
;

namespace `core.http` (
    class ModuleLoader extends core.http.ResourceLoader{

        constructor (){
            super()
            return this;
        }
        
        load(ns,filepath, cb){
            var head  = document.getElementsByTagName("head").item(0);
            var script = document.createElement("script");
            script.setAttribute("type", "module");
            script.setAttribute("charset", (Config.CHARSET || "utf-8"));
            script.src = filepath;
            head.appendChild(script);
            cb?cb(script):null;
        }
    }
);

document.addEventListener("DOMContentLoaded", e => {
  async function bootup() {
    var ns = Config.NAMESPACE;//||resolveNs();
    if (Config.DYNAMICLOAD) {
      var filename_path = (
        Config.SRC_PATH + (ns.replace(/\./g, "/"))  + "/" + Config.FILENAME
      );
      var path = filename_path.replace("*", Config.USE_COMPRESSED_BUILD ? "min.":"");
      var c = (Config.ENABLE_TRANSPILER) ?
        new core.http.ClassLoader :
        new core.http.ModuleLoader;
          c.load(ns, Config.ROOTPATH + path, data => {});
    }
  };

  // function  resolveNs() {
  //   var nsPath = location.href.split(Config.SRC_PATH)[1];
  //   var parts  = nsPath?nsPath.split("/"):null;;
  //       parts  = !parts||parts.length <=0?null:`${parts[0]}.${parts[1]}`;
  //   return parts;
  // }

  ("cordova" in window) ? 
    document.addEventListener('deviceready', ()=>{
      AndroidFullScreen.immersiveMode(e=>{}, e=>{});
      bootup()
    }, false) : bootup()
}, false);

console.log(`🦏 Oros Engine - v${$framework.current}`)