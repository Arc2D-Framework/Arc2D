<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Component Packaging</h1>
        <p>
          Components may be packaged in 1 of 2 ways. 
          <ul>
            <li>Prefab Components (baked)</li>
            <li>Packaged Components</li>
          </ul>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Prefab Components</h1>
        <p>
          Components rely on assets such as a Class(js), a Template(html) and Styling (css). 3 core assets that define the most basic component. Baked, or Prefab Components allow you to define the Javascript Class with it's CSS and HTML template inline, within the JavaScript, essentially bundling, or baking the component with everything needed up-front.
        </p>
        <p>
          <img src="src/docs/images/baked_component_dir.png" style="float:right;width:200px;"/>
          This decreases load time when importing the component at runtime. When bundling a component this way, there is no folder needed because there are no loose assets. The convention is to then name the JavaScript file after it's class name, hence, "CoverFlow.js". But still residing in the folder structure that matches it's namespace, ex "core/ui/CoverFlow.js" matching namespace token "core.ui.CoverFlow".
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            All prefab(baked) into 1 file. When <code style="display:inline;">core.ui.CoverFlow</code> is imported elsewhere, only CoverFlow.js is loaded with its css and template applied as usual. Nothing else about the component is different other than faster load time.
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`core.ui\` (
  class CoverFlow extends w3c.ui.WebComponent {
    //js code hidden for example

    cssStyle(){
      return \`
        .CoverFlow {
          display:block;
          width:300px;
          height:150px;
        }
        .CoverFlow .items {
          float:left;
          width:100px;
          height:100%;
        }
      \`
    }

    template(){
      return \`
        &#x3C;template&#x3E;
            &#x3C;div&#x3E;
                &#x3C;ul&#x3E;
                     &#x3C;li class=&#x22;item&#x22;&#x3E;&#x3C;/li&#x3E;
                     &#x3C;li class=&#x22;item&#x22;&#x3E;&#x3C;/li&#x3E;
                     &#x3C;li class=&#x22;item&#x22;&#x3E;&#x3C;/li&#x3E;
                &#x3C;/ul&#x3E;
            &#x3C;/div&#x3E;
        &#x3C;/template&#x3E;
      \`
    }
  }
)
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            <em style="color:black;">Main drawback</em> to this approach is code that it is non-cohesive. Harder to follow. The amount of modification to the file increases, increasing complexity and introducing bugs. This should only be done with good judgment unlike React that is a proponent of this strategy completely and even more difficult and expensive in terms of CPU and syntax/api.
          </blockquote>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Packaged Components</h1>
        <p>
          <em>This model is recommended for development, testing, debugging and production</em> and only baked when absolutely necessary. <b>Packaged Components use a folder named after the Class</b> to store it's javascript, css and html files.
        </p>
        <p>
          <img src="src/docs/images/cover_flow_dir_structure.png" style="float:right; width:200px;"/>
          The @stylesheets decorator is used for linking in it's css file. No need to tell it about the html template. The component makes an intelligent decision when and if to even load an external template, as we'll see later. The only convention in this folder setup is that:
          <ul>
            <li>each asset should be named as index, ex</li>
            <li>index.js</li>
            <li>index.css</li>
            <li>index.html</li>
          </ul>
        </p>
        <p>
          These 3 core assets must be named in this manner. If the component supports altering it's html template dynamically or requires additional .css files. They maybe be named in any way you like because these are controlled and loaded by you explicitly. (Later topic covers templating in-depth).
        </p>


        <h1>Fully-Qualified Namespaced Components</h1>
        <p>
          Components should be stored in a folder-tree that matches
          the components fully qualified namespace. Where:
          <ul>
            <li>The component namespace is all lower.cased<br/>Ex: 'core.game.weapons'</li>
            <li>The components Class Name is UpperCased<br/>Ex: 'LongSword'</li>
            <li>The components <em>fully-qualified</em> name == namespace + Class name combined. <br/>Ex: core.game.weapons.LongSword</li>
            <li>Folder-trees inside <em>src/ directory matches the fully qualified namespaces</em></li>
          </ul>
          Below is a component defined with a namespace, "core.ui":
          <pre class="inline javascript lang"><code>namespace \`core.ui\` (
    class ModalDialog extends w3c.ui.WebComponent {
        constructor(){
            //body 
        }
    }
)</code></pre> 
      <br/>The class name is "ModalDialog". The <b>fully qualified namespace</b> is then: <code>core.ui.ModalDialog</code>
        </p>
        <p>
          In the src/ directory, a folder-tree mirrors the fully qualified namespace. The final Class folder should contain the 3 asset files for the Component:<br/>
          <img src="src/docs/images/folder-tree-matches-namespace.png" style="width:260px;"/>
        </p>

      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang">
          <blockquote class="javascript" style="display:block;width: 100%;">
            /src/core/ui/CoverFlow/index.js:
          </blockquote>
          <pre class="highlight javascript" style="display:block;width: 100%;"><code>
namespace \`core.ui\` (
  @stylesheets(['/src/./index.css', '/src/./other.css']);
  class CoverFlow extends w3c.ui.WebComponent {
    //assets in folder, see:  core/ui/CoverFlow
  }
)
        </code></pre>
        <blockquote class="javascript" style="display:block;width: 100%;">
            Take note on @stylesheets decorator. We covered it in <a href="#docs.topics.JavascriptDecorators/stylesheets">Language & Syntax</a> earlier. Here's we're loading index.css and some other.css.
            <br/>
            <em style="color:black;">In v3.3</em> - we will consider letting the component auto-load index.css in roughly the same way it handles the loading of it's template. This will make for even cleaner syntax.
          </blockquote>
        </div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>
  </div>
</template>