<template>
  <div>

    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Activity Life Cycle</h1>
        <p>
          We've been using the terms, Activity and Views interchangeably. "Views" were mentioned abstractly to mean a UI component appearing in an applications view-port. But how views transition in and out of a view-port is a design pattern in Arc called Activities.
        </p>
        <p>
            Navigating to views by links:
            <pre class="inline html lang"><code>&#x3C;a href=&#x22;#screens.BlackFridayDeals&#x22;&#x3E;Shop Black Friday Specials&#x3C;/a&#x3E;</code></pre><br/>

            is a design decision that required an intelligent, real-time routing mechanism that limits any pre-configured "wire-ups". Developers leverage existing knowledge of simple anchros to achieve graceful navigation between views.
        </p>
       
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Activity Life Cycle</h1>
        <p>
          An activity moves through a sequence of of event callbacks before, during and after it is requested for display. These callbacks can be used from the application level to enter and exit the previous activity (if there is a previous). The sequence of events are as follows:
          <table>
            <thead>
            <tr>
              <th>Event Sequence</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="width: 200px;"><code>1. onResumeActivity</code></td>
              <td>application notified that a previous activity from memory is being resumed once more. Never fires if there is no previous activity.</td>
            </tr>
            <tr>
              <td><code>1. onLoadingActivity</code></td>
              <td>application notified that an activity is being loaded for the first time, only fires once or never if the activity was previously loaded.</td>
            </tr>
            <tr>
              <td><code>2. onExitActivity</code></td>
              <td>application notified that the current activity, if there is one, is being exited for next activity. Runs everytime.</td>
            </tr>
            <tr>
              <td><code>3. onEnterActivity</code></td>
              <td>application notified that the next activity can be transitioned into view. Will now be the currently running activity. Runs everytime.</td>
            </tr>
            <!-- <tr>
              <td><code>onResumeActivity</code></td>
              <td>application notified that a previously displayed activity is being resumed back into focus (view-port)</td>
            </tr> -->
          </tbody>
        </table>
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">onResumeActivity</h1>
        <p>
          <code>onResumeActivity</code> is an optional implementation. It notifies your application for convenience sake that a previously loaded activity instance is being requested for display again but never fires if there was never an instance of the activity in memory. Use-cases are out of scope here.
        </p>
        <p>
            An implementation may resemble:
            <pre class="inline javascript lang"><code>
onResumeActivity(activity){
    console.log("Resuming Activity", activity);
}
            </code></pre><br/>
        </p>
       
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">onLoadingActivity</h1>
        <p>
          <code>onLoadingActivity</code> is an optional implementation. It notifies your application for convenience sake that the requested activity is being loaded for the first time, gauranteed to fire just once. Use-cases are out of scope here.
        </p>
        <p>
            An implementation may resemble:
            <pre class="inline javascript lang"><code>
onLoadingActivity(activity){
    console.log("Loading Activity", activity);
}
            </code></pre><br/>
        </p>
       
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>




    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">onExitActivity</h1>
        <p>
          <code>onExitActivity</code> is an optional implementation and runs even if there was no current activity. It notifies the application that
          the requested current activity being shown is leaving the view-port. The framework places no assumption or implementation on how/what to do to leave the current activity.
        </p>
        <p>
          Your implementation of <code>onExitActivity</code> is responsible for destroying the activity from memory or simply clear out the view-port for the next activity being entered into. A simple implementation is as follows:
          <ul>
              <li>Find the view port slot</li>
              <li>Clear the slot</li>
          </ul>
        </p>
        <p>
            An implementation may resemble:
            <pre class="inline javascript lang"><code>
onExitActivity (current) {
    var slot = this.querySelector('#content');
        slot.innerHTML="";
}
            </code></pre><br/>
        </p>
        <p>
            If no implementation is provided by your application, activities will be appended to the view-port, stacked on top of each other yielding an additive effect if that is a disarable feature of your UI.
        </p>
        <p>The above implementation only clears the view-port and leaves the activity in memory for faster switching the next time it resumes.</p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">onEnterActivity</h1>
        <p>
          <code>onEnterActivity</code> is a required implementation. It notifies the application that
          the requested activity is being entered but assumes no responsibility for how or when it is displayed in the view-port. 
        </p>
        <p>
          Your implementation of <code>onEnterActivity</code> is responsible for displaying the activity in whichever manner you choose. As a simple implementation of just displaying the activity without any special transitions, you can follow these steps:
          <ul>
              <li>Find the view port slot</li>
              <li>Insert the activity into the slot</li>
          </ul>
        </p>
        <p>
            An implementation may resemble:
            <pre class="inline javascript lang"><code>
onEnterActivity (activity, scrollTo) {
    var slot = this.querySelector('#content');
        slot.appendChild(activity);
}
            </code></pre><br/>
        </p>
        <p>
            Of course, the implementation can both clear and inject the next activity, be pragmatic. Here we let each handler do just one simple thing. Also this could be more fancy, applying 2D animation fx or css transforms/opacity to ease in the display, but for brevity and in most cases, the above implementation is sufficient for simulating how a page loads (browser refresh).
        </p>
        <p>
            Because the framework does not handle display, you are in complete and utter control of creative ideas. Think of the possibilities, instead of appending the activity to a div, your slot can be yet another component, something like a cover-flow component, that accepts activities being pushed into it and rotated in 3D space for an interesting UI effect.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>





    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Remarks</h1>
        <p>
          You should have an understanding by now on how to redirect to activities and the life-cycle of events that trigger for activities being requested for the view-port. There are no other mechanics or wire-up required. Activities are regular web components and don't inherit from any special base class. Any component can serve as an activity for the applications view-port.
        </p>
        <p>
            The view-port does not have to be a div, it can be a slot or any other custom component that knows how to accept activities into its queue and transition to them.
        </p>
       
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



  </div>
</template>