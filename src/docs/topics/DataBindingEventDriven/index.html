<template>
  <div>

    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Data Binding: Event-driven Control</h1>
        <p>
            The principals of event-driven architecture lends to conclusion that a subscriber registers to events (or signals) being emmitted from a publisher so as to react to those signals. Event-driven programming is wide and deep, see wikipedia for a more immersive explanation. In regards to GUI development, events rarely leave the system in its purest form but are interpreted by subscribers to handle the action in some meaningful way.
        </p>
        <p>
            Event emmitters in the GUI realm, are considered EventTargets -- the target, or source of emmission of signals. EventTargets, generally are and in most cases, DOM Nodes. Events from these nodes fire when their state changes. For example, a common set of events are:
            <ul>
                <li>clicks</li>
                <li>mouse down; up</li>
                <li>key presses</li>
                <li>hover states</li>
                <li>mutation changes</li>
                <li>and many more</li>
            </ul>
            See <a href="https://www.w3.org/wiki/List_of_events" target="new">List of events (W3C)</a>
        </p>
        <p>
            Data Binding is all about reacting to state change, the core principal is to synchronize state between 2 objects, in essence, working like a mirror, reflecting state from one object upon another. In real-time, data binding aims to "keep up" with live state changes, reflecting one value of state unto another object, again to keep 2 objects in sync.
        </p>
        <p>
            It turns out that Data Binding, as elegant as it is, can be achieved at a a grandular, rudimentary level in code using an event-driven style of programming. In fact, you've done this all along, all the time, all your career, not realizing you've been manually writing boiler-plate wire-up logic to connect event targets to subscribers (event handlers), effectively "data binding" 2 parts together so as to respond to the user-interface events being triggered arbitarily by some user clicking or tapping on that "Send" button.
        </p>
        <p>
            What this really means is that event-driven programming is a fundemental principal behind the "magic" and elegance of the Data Binding design pattern. What makes data binding special is that it is a living and dynamic relationship, to enforce synchronization, where as an event wire-up binding is less live but offers great control and is generally more performant and deterministic.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



    
    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Liveness</h1>
        <p>
            Well, what does liveness mean? First, let's compare the syntax between data binding in Oros and event listening:

            
            <pre class="inline javascript lang"><code>
//Data Binding Example: Watch person.firstname for changes
this.watch(person, 'firstname', e => console.log(e.val));
        </code></pre>


        <pre class="inline javascript lang"><code>
//Event Listener Example: Listen for person state changes
person.addEventListener('change', e => console.log(e.data.value));
        </code></pre>
        </p>

        <p>
            An analytical look at these two examples reveal a similarity, notification of state changes. But a difference in mechanics. Data Binding ties into an object, with greater percision, down to the property/attribute level of an object.
        </p>
        <p>
            The event driven form, listens for state change at the surface level of an object, never piercing it's encapsulated composite, or at least, tries not to. It says, "Hey, person, I know somethings going on within you, I won't constantly ask, just tell me when you change". But Data Binding is always asking, maybe every 1 second, 300ms, maybe every 30FPS, indefinitely, until some condition in code slaps him out of it with a call to <code>.unwatch()</code>.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>

    


    <div style="display: flex;flex-direction: row;flex-wrap: nowrap;">
      <div style="width: 50%;padding: 22px;">
        <h1 id="api-reference">Elegance</h1>
        <p>
            What makes Data Binding elegant? It's supple, lean syntax gurantees awareness of state changes in real-time, accurately, promising tight synchronization indefinitely and cheap to use. But taxing.
        </p>
        <p>
            You see, event wire-up registers to be notified and rests, it waits, no polling or checking. The EventTarget (the person in this example), may have a method such as setName(), that after setting the attribute value, may emit a "change" event if it wants to immediately, maybe queues it, or debounces it. Maybe delays. But eventually, the event handler will be notified and code can be written to reflect that state unto the View, or perhaps congratualte the person on finally changing his/her name. 
        </p>
        <p>
            In addition, event-driven style does not gurantee that an object fires a certain event. Every Emmitter will have code in most cases, logically deciding when and if to fire events, especially custom domain-driven events, so it's not for free, you have to program objects to fire events and consume them.
        </p>
        <p>
            The elegance of Data Binding alludes us through laziness or unknowingly, to use it almost free but at a cost. It's promise to keep pieces informed reveals what really takes place "under the hood" to gurantee this kind of beauty. Since it watches an attribute at the property/member level without having to program anything in the emitter to notify bindings, it can be taxing due to the level of scrutinity. So be cautious and aware of it's use.
        </p>
        <p>
            Lets have a look at dynamic and live <a href="#docs.topics.DataBindingReflection">Data Binding</a>.
        </p>
      </div>
      <div style="width: 50%;display: block;">
        <div class="shell lang"></div>
        <div class="javascript lang"></div>
        <div class="html lang"></div>
        <div class="css lang"></div>
      </div>
    </div>



  </div>
</template>